diff --git a/docs/cn/mbvar_c++.md b/docs/cn/mbvar_c++.md
new file mode 100644
index 0000000..54dda9a
--- /dev/null
+++ b/docs/cn/mbvar_c++.md
@@ -0,0 +1,774 @@
+- [Introduction](#introduction)
+- [bvar::MVariables](#bvarmvariables)
+  - [expose](#expose)
+    - [expose](#expose-1)
+    - [expose_as](#expose_as)
+  - [Export all MVariable](#export-all-mvariable)
+  - [count](#count)
+    - [count_exposed](#count_exposed)
+  - [list](#list)
+    - [list_exposed](#list_exposed)
+- [bvar::MultiDimension](#bvarmultidimension)
+  - [constructor](#constructor)
+  - [stats](#stats)
+    - [get_stats](#get_stats)
+  - [count](#count-1)
+    - [count_labels](#count_labels)
+    - [count_stats](#count_stats)
+  - [list](#list-1)
+    - [list_stats](#list_stats)
+  - [template](#template)
+    - [bvar::Adder](#bvaradder)
+    - [bvar::Maxer](#bvarmaxer)
+    - [bvar::Miner](#bvarminer)
+    - [bvar::IntRecorder](#bvarintrecorder)
+    - [bvar::LatencyRecorder](#bvarlatencyrecorder)
+    - [bvar::Status](#bvarstatus)
+
+# Introduction
+
+bvar多维度统计使用文档
+
+mbvar中有两个类，分别是MVariable和MultiDimension，MVariable是多维度统计的基类，MultiDimension是派生模板类，目前支持如下几种类型：
+
+| bvar类型 | 说明 |
+| ------ | ------ |
+| bvar::Adder<T> | 计数器，默认0，varname << N相当于varname += N。 |
+| bvar::Maxer<T> | 求最大值，默认std::numeric_limits<T>::min()，varname << N相当于varname = max(varname, N)。 |
+| bvar::Miner<T> | 求最小值，默认std::numeric_limits<T>::max()，varname << N相当于varname = min(varname, N)。 |
+| bvar::IntRecorder | 求自使用以来的平均值。注意这里的定语不是“一段时间内”。一般要通过Window衍生出时间窗口内的平均值。 |
+| bvar::LatencyRecorder | 专用于记录延时和qps的变量。输入延时，平均延时/最大延时/qps/总次数 都有了。 |
+| bvar::Status<T> | 记录和显示一个值，拥有额外的set_value函数 |
+
+例子：
+```c++
+#include <bvar/bvar.h>
+#include <bvar/multi_dimension.h>
+
+namespace foo {
+namespace bar {
+// 定义一个全局多维度mbvar变量
+bvar::MultiDimension<bvar::Adder<int> > g_request_count("request_count", {"idc", "method", "status"});
+// bvar::MultiDimension<bvar::Adder<int> > g_request_count("foo_bar", "request_count", {"idc", "method", "status"});
+
+int process_request(const std::list<std::string>& request_label) {
+    // 获取request_label对应的单维度bvar指针，比如：request_label = {"tc", "get", "200"}
+    bvar::Adder<int>* adder = g_request_count.get_stats(request_label);
+    // 判断指针非空
+    if (!adder) {
+        return -1;
+    }
+    // adder只能在g_request_count的生命周期内访问，否则行为未定义，可能会出core
+    // 给adder输入一些值
+    *adder << 1 << 2 <<3;
+    LOG(INFO) << "adder=" << *adder; // adder add up to 6
+    ...
+    return 0;
+}
+
+} // namespace bar
+} // namespace foo
+```
+
+# bvar::MVariables
+MVariale是MultiDimension(多维度统计)的基类，主要提供全局注册、列举、查询和dump等功能。
+
+## expose
+
+### expose
+
+用户在创建mbvar变量(bvar::MultiDimension)的时候，如果使用一个参数的构造函数(共有三个构造函数)，这个mbvar并未注册到任何全局结构中(当然也不会dump到本地文件)，在这种情况下，mbvar纯粹是一个更快的多维度计数器。我们称把一个mbvar注册到全局表中的行为为“曝光”，可以通过expose函数曝光：
+
+```c++
+class MVariable {
+public
+    ...
+    // Expose this mvariable globally so that it's counted in following
+    // functions:
+    //     list_exposed
+    //     count_exposed
+    // Return 0 on success, -1 otherwise.
+    int expose(const base::StringPiece& name);
+    int expose_as(const base::StringPiece& prefix, const base::StringPiece& name);
+};
+```
+
+全局曝光后的mbvar名字便为name或者prefix+name，可通过以_exposed为后缀的static函数查询。比如MVariable::describe_exposed(name)会返回名为name的mbvar的描述。
+
+当相同名字的mbvar已存在时，expose会打印FATAL日志并返回-1。如果选项-bvar_abort_on_same_name设为true (默认是false)，程序会直接abort。
+
+下面是一些曝光mbvar的例子：
+```c++
+#include <bvar/bvar.h>
+#include <bvar/multi_dimension.h>
+
+namespace foo {
+namespace bar {
+// 定义一个全局的多维度mbvar变量
+bvar::MultiDimension<bvar::Adder<int> > g_request_count("request_count", {"idc", "method", "status"});
+
+// 换一个名字
+g_request_count->expose("request_count_another");
+
+int process_request(const std::list<std::string>& request_label) {
+    // 获取request_label对应的单维度bvar指针，比如：request_label = {"tc", "get", "200"}
+    bvar::Adder<int>* adder = g_request_count.get_stats(labels_value);
+    // 判断指针非空
+    if (!adder) {
+        return -1;
+    }
+
+    //adder只能在g_request_count的生命周期内访问，否则行为未定义，可能会出core
+    *adder << 10 << 20 << 30; // adder add up to 60
+}
+
+} // namespace bar
+} // namespace foo
+```
+
+### expose_as
+
+为了避免重名，mbvar的名字应加上前缀，建议为\<namespace\>\_\<module\>\_\<name\>。为了方便使用，我们提供了expose_as函数，接收一个前缀。
+```c++
+class MVariable {
+public
+    ...
+    // Expose this mvariable with a prefix.
+    // Example:
+    //   namespace foo {
+    //   namespace bar {
+    //
+    //      bvar::MultiDimension<bvar::Adder<int> > g_request_count("request_count", {"idc", "method", "status"});
+    //      g_request_count.expose_as("foo_bar", "request_count");
+    //      ...
+    //
+    //   }  // foo
+    //   }  // bar
+    int expose_as(const base::StringPiece& prefix, const base::StringPiece& name);
+};
+```
+
+## Export all MVariable
+提供dump_exposed函数导出进程中所有已曝光的mbvar：
+
+```c++
+// Implement this class to write mvariables into different places.
+// If dump() returns false, MVariable::dump_exposed() skip and continue dump.
+class Dumper {
+public:
+    virtual bool dump(const std::string& name, const base::StringPiece& description) = 0;
+};
+
+// Options for MVariable::dump_exposed().
+struct DumpOptions {
+    // Contructed with default options.
+    DumpOptions();
+    // If this is true, string-type values will be quoted.
+    bool quote_string;
+    // The ? in wildcards. Wildcards in URL need to use another character
+    // because ? is reserved.
+    char question_mark; // 目前不支持
+    // Separator for white_wildcards and black_wildcards.
+    char wildcard_separator; // 目前不支持
+    // Name matched by these wildcards (or exact names) are kept.
+    std::string white_wildcards; // 目前不支持
+    // Name matched by these wildcards (or exact names) are skipped.
+    std::string black_wildcards; // 目前不支持
+};
+
+class MVariable {
+    ...
+    ...
+    // Find all exposed mvariables and send them to `dumper'.
+    // Use default options when `options' is NULL.
+    // Return number of dumped mvariables, -1 on error.
+    static size_t dump_exposed(Dumper* dumper, const DumpOptions* options);
+};
+```
+
+最常见的导出需求是通过HTTP接口查询和写入本地文件，多维度统计暂时不提供HTTP接口方式查询，后者已经在bvar中实现了，由用户选择开启，该功能由下面5个gflags控制，你的程序需要使用gflags。
+
+| 名称 | 默认值 | 描述 |
+| ------ | ------ | ------ |
+| mbvar_dump |false	| Create a background thread dumping(shares the same thread as bvar_dump) all mbvar periodically, all bvar_dump_* flags are not effective when this flag is off |
+| mbvar_dump_file | monitor/mbvar.\<app\>.data | Dump mbvar into this file |
+| mbvar_dump_format	| common | Dump mbvar write format <br> common：文本格式，Key和Value用冒号分割(和目前的单维度dump文件格式一致) <br><br> prometheus：文本格式，Key和Value用空格分开protobuf：二进制格式，暂时不支持|
+| bvar_dump_interval | 10 |Seconds between consecutive dump |
+| mbvar_dump_prefix | \<app\> | Every dumped name starts with this prefix |
+
+用户可在程序启动前加上对应的gflags。
+
+>当mbvar_dump=true并且mbvar_dump_file不为空时，程序会启动一个后台导出线程以bvar_dump_interval指定的间隔更新mbvar_dump_file，其中包含所有的多维统计项mbvar。
+
+比如我们把所有的gflags修改为下表：
+| 名称 | 默认值 | 描述 |
+| ------ | ------ | ------ |
+| mbvar_dump |true	| Create a background thread dumping(shares the same thread as bvar_dump) all mbvar periodically, all bvar_dump_* flags are not effective when this flag is off |
+| mbvar_dump_file | monitor/mbvar.\<app\>.data | Dump mbvar into this file |
+| mbvar_dump_format	| common | Dump mbvar write format <br> common：文本格式，Key和Value用冒号分割(和目前的单维度dump文件格式一致) <br><br> prometheus：文本格式，Key和Value用空格分开protobuf：二进制格式，暂时不支持|
+| bvar_dump_interval | 10 |Seconds between consecutive dump |
+| mbvar_dump_prefix | mbvar | Every dumped name starts with this prefix |
+
+导出的本地文件为monitor/mbvar.\<app\>.data：
+```
+mbvar_test_concurrent_write_and_read{idc=idc3,method=method6,status=status40} : 76896
+mbvar_test_concurrent_write_and_read{idc=idc5,method=method6,status=status36} : 147910
+mbvar_test_concurrent_write_and_read{idc=idc5,method=method12,status=status23} : 209270
+mbvar_test_concurrent_write_and_read{idc=idc3,method=method1,status=status6} : 116325
+mbvar_test_concurrent_write_and_read{idc=idc5,method=method10,status=status29} : 193536
+mbvar_test_concurrent_write_and_read{idc=idc5,method=method15,status=status6} : 294726
+mbvar_test_concurrent_write_and_read{idc=idc3,method=method2,status=status13} : 136676
+mbvar_test_concurrent_write_and_read{idc=idc2,method=method5,status=status49} : 43203
+mbvar_test_concurrent_write_and_read{idc=idc5,method=method10,status=status1} : 312499
+mbvar_test_concurrent_write_and_read{idc=idc1,method=method10,status=status35} : 35698
+```
+
+如果你的程序没有使用brpc，仍需要动态修改gflags（一般不需要），可以调用google::SetCommandLineOption()，如下所示：
+
+```c++
+#include <gflags/gflags.h>
+...
+if (google::SetCommandLineOption("mbvar_dump_format", "prometheus").empty()) {
+    LOG(ERROR) << "Fail to set mbvar_dump_format";
+    return -1;
+}
+LOG(INFO) << "Successfully set mbvar_dump_format to prometheus";
+```
+
+>请勿直接设置 FLAGS_mbvar_dump_file / FLAGS_mbvar_dump_format / FLAGS_bvar_dump_prefix，如果有需求可以调用google::SetCommandLineOption()方法进行修改。
+
+一方面这些gflag类型都是std::string，直接覆盖是线程不安全的；另一方面不会触发validator（检查正确性的回调），所以也不会启动后台导出线程。
+
+
+## count
+统计相关函数
+```c++
+class MVariable {
+public:
+    ...
+    // Get number of exposed mvariables
+    static size_t count_exposed();
+};
+```
+
+### count_exposed
+
+获取目前已经曝光的多维度统计项mbvar的个数，注意：这里是多维度统计项(多维度mbvar变量)，而不是维度数。
+```c++
+#include <bvar/bvar.h>
+#include <bvar/multi_dimension.h>
+
+namespace foo {
+namespace bar {
+// 定义一个全局的多维度mbvar变量
+bvar::MultiDimension<bvar::Adder<int> > g_request_count("request_count", {"idc", "method", "status"});
+
+// 定义另一个全局多维度mbvar变量
+bvar::MultiDimension<bvar::Adder<int> > g_psmi_count("psmi_count", {"product", "system", "module", "interface"});
+
+size_t count_exposed() {
+    size_t mbvar_count_exposed = bvar::MVariable::count_exposed();
+    CHECK_EQ(2, mbvar_count_exposed);
+    return mbvar_count_exposed;
+}
+
+} // namespace bar
+} // namespace foo
+```
+
+使用说明
+> 一般情况下用不到count_系列统计函数，如果有特殊需求，也不建议频繁调用。
+
+
+## list
+```c++
+class MVariable {
+public:
+    ...
+    // Put names of all exposed mbvariable into `names'
+    static size_t list_exposed(std::vector<std::string>* names);
+};
+```
+
+### list_exposed
+获取所有曝光的多维度统计项mbvar名称
+```c++
+#include <bvar/bvar.h>
+#include <bvar/multi_dimension.h>
+
+namespace foo {
+namespace bar {
+// 定义一个全局的多维度mbvar变量
+bvar::MultiDimension<bvar::Adder<int> > g_request_count("request_count", {"idc", "method", "status"});
+
+// 定义另一个全局多维度mbvar变量
+bvar::MultiDimension<bvar::Adder<int> > g_psmi_count("psmi_count", {"product", "system", "module", "interface"});
+
+size_t mbvar_list_exposed(std::vector<std::string>* names) {
+    if (!names) {
+        return -1;
+    }
+
+    // clear
+    names.clear();
+    bvar::MVariable::list_exposed(names);
+    // names：[ "request_count", "psmi_count" ]
+    CHECK_EQ(2, names->size());
+    return names->size();
+}
+
+} // namespace bar
+} // namespace foo
+```
+
+# bvar::MultiDimension
+
+多维度统计的实现，主要提供bvar的获取、列举等功能。
+
+## constructor
+
+有三个构造函数：
+```c++
+template <typename T>
+class MultiDimension : public MVariable {
+public:
+    // 不建议使用
+    explicit MultiDimension(const key_type& labels);
+
+    // 推荐使用
+    MultiDimension(const base::StringPiece& name,
+                   const key_type& labels);
+    // 推荐使用
+    MultiDimension(const base::StringPiece& prefix,
+                   const base::StringPiece& name,
+                   const key_type& labels);
+    ...
+};
+```
+
+**explicit MultiDimension(const key_type& labels)**
+
+* ~~不建议使用~~
+* 不会“曝光”多维度统计变量(mbvar)，即没有注册到任何全局结构* 中
+* 不会dump到本地文件，即使-bvar_dump=true、-mbvar_dump_file不为空
+* mbvar纯粹是一个更快的多维度计数器
+
+**MultiDimension(const base::StringPiece& name, const key_type& labels)**
+
+* **推荐使用**
+* 会曝光(调用MVariable::expose(name))，也会注册到全局结构中
+* -bvar_dump=true时，会启动一个后台导出线程以bvar_dump_interval指定的时间间隔更新mbvar_dump_file文件
+
+```c++
+#include <bvar/bvar.h>
+#include <bvar/multi_dimension.h>
+
+namespace foo {
+namespace bar {
+// 定义一个全局的多维度mbvar变量
+bvar::MultiDimension<bvar::Adder<int> > g_request_count("request_count", {"idc", "method", "status"});
+
+} // namespace bar
+} // namespace foo
+```
+
+**MultiDimension(const base::StringPiece& prefix, const base::StringPiece& name, const key_type& labels)**
+* **推荐使用**
+* 会曝光(调用MVariable::expose_as(prefix, name))，也会注册到全局结构中
+* -bvar_dump=true时，会启动一个后台导出线程以bvar_dump_interval指定的时间间隔更新mbvar_dump_file文件
+
+```c++
+#include <bvar/bvar.h>
+#include <bvar/multi_dimension.h>
+
+namespace foo {
+namespace bar {
+// 定义一个全局的多维度mbvar变量
+bvar::MultiDimension<bvar::Adder<int> > g_request_count("foo_bar", "request_count", {"idc", "method", "status"});
+
+} // namespace bar
+} // namespace foo
+```
+
+## stats
+```c++
+template <typename T>
+class MultiDimension : public MVariable {
+public:
+    ...
+
+    // Get real bvar pointer object
+    // Return real bvar pointer(Not NULL) on success, NULL otherwise.
+    T* get_stats(const std::list<std::string>& labels_value);
+};
+```
+
+### get_stats
+根据指定label获取对应的单维度统计项bvar
+```c++
+#include <bvar/bvar.h>
+#include <bvar/multi_dimension.h>
+
+namespace foo {
+namespace bar {
+// 定义一个全局的多维度mbvar变量
+bvar::MultiDimension<bvar::Adder<int> > g_request_count("request_count", {"idc", "method", "status"});
+
+int get_request_count(const std::list<std::string>& request_label) {
+    // 获取request_label对应的单维度bvar指针，比如：request_label = {"tc", "get", "200"}
+    bvar::Adder<int> *request_adder = g_request_count.get_stats(request_label);
+    // 判断指针非空
+    if (!request_adder) {
+        return -1;
+    }
+
+    // request_adder只能在g_request_count的生命周期内访问，否则行为未定义，可能会出core
+    *request_adder << 1;
+    return request_adder->get_value();
+}
+
+} // namespace bar
+} // namespace foo
+```
+
+**内部实现逻辑**
+
+判断该label是否已经存在对应的单维度统计项bvar：
+
+* 存在
+    * return bvar
+* 不存在
+    * new bvar()
+    * store(bvar)
+    * return bvar
+
+**bvar的生命周期**
+
+label对应的单维度统计项bvar存储在多维度统计项(mbvar)中，当mbvar析构的时候会释放自身所有bvar，所以用户必须保证在mbvar的生命周期之内操作bvar，在mbvar生命周期外访问bvar的行为未定义，极有可能出core。
+
+## count
+```c++
+class MVariable {
+public:
+    ...
+
+    // Get number of mvariable labels
+    size_t count_labels() const;
+};
+
+template <typename T>
+class MultiDimension : public MVariable {
+public:
+    ...
+
+    // Get number of stats
+    size_t count_stats();
+};
+```
+
+### count_labels
+
+获取多维度统计项的labels个数，用户在创建多维度(bvar::MultiDimension)统计项的时候，需要提供类型为std::list\<std::string\>的labels变量，我们提供了count_labels函数，返回labels的长度。
+
+```c++
+#include <bvar/bvar.h>
+#include <bvar/multi_dimension.h>
+
+namespace foo {
+namespace bar {
+// 定义一个全局的多维度mbvar变量
+bvar::MultiDimension<bvar::Adder<int> > g_request_count("request_count", {"idc", "method", "status"});
+
+size_t count_labels() {
+    size_t mbvar_count_labels = g_request_count.count_labels();
+    CHECK_EQ(3, mbvar_count_labels);
+    return mbvar_count_labels;
+}
+} // namespace bar
+} // namespace foo
+```
+
+### count_stats
+
+获取多维度(bvar::MultiDimension)统计项的维度(stats)数
+```c++
+#include <bvar/bvar.h>
+#include <bvar/multi_dimension.h>
+
+namespace foo {
+namespace bar {
+// 定义一个全局的多维度mbvar变量
+bvar::MultiDimension<bvar::Adder<int> > g_request_count("request_count", {"idc", "method", "status"});
+
+size_t count_stats() {
+    // 获取request1对应的单维度mbvar指针，假设request1_labels = {"tc", "get", "200"}
+    bvar::Adder<int> *request1_adder = g_request_count.get_stats(request1_labels);
+    // 判断指针非空
+    if (!request1_adder) {
+        return -1;
+    }
+    // request1_adder只能在g_request_count生命周期内访问，否则行为未定义，可能会出core
+    *request1_adder << 1;
+
+    // 获取request2对应的单维度mbvar指针，假设request2_labels = {"nj", "get", "200"}
+    bvar::Adder<int> *request2_adder = g_request_count.get_stats(request2_labels);
+    // 判断指针非空
+    if (!request2_adder) {
+        return -1;
+    }
+    // request2_adder只能在g_request_count生命周期内访问，否则行为未定义，可能会出core
+    *request2_adder << 1;
+
+
+    size_t mbvar_count_stats = g_request_count.count_stats();
+    CHECK_EQ(2, mbvar_count_stats);
+    return mbvar_count_stats;
+}
+} // namespace bar
+} // namespace foo
+```
+
+## list
+```c++
+template <typename T>
+class MultiDimension : public MVariable {
+public:
+    ...
+    // Put all stats labels into `names'
+    void list_stats(std::vector<std::list<std::string> >* names);
+};
+```
+
+### list_stats
+获取一个多维度统计项下所有labels组合列表
+
+```c++
+#include <bvar/bvar.h>
+#include <bvar/multi_dimension.h>
+
+namespace foo {
+namespace bar {
+// 定义一个全局的多维度mbvar变量
+bvar::MultiDimension<bvar::Adder<int> > g_request_count("request_count", {"idc", "method", "status"});
+
+size_t list_stats(std::vector<std::list<std::string> > *stats_names) {
+    if (!stats_names) {
+        return -1;
+    }
+
+    // clear
+    stats_names.clear();
+
+    // 获取request1对应的单维度mbvar指针，假设request1_labels = {"tc", "get", "200"}
+    bvar::Adder<int> *request1_adder = g_request_count.get_stats(request1_labels);
+    // 判断指针非空
+    if (!request1_adder) {
+        return -1;
+    }
+
+    // 获取request2对应的单维度mbvar指针，假设request2_labels = {"nj", "get", "200"}
+    bvar::Adder<int> *request2_adder = g_request_count.get_stats(request2_labels);
+    // 判断指针非空
+    if (!request2_adder) {
+        return -1;
+    }
+
+    g_request_count.list_stats(stats_names);
+    // labels_names：
+    // [
+    //      {"tc", "get", "200"},
+    //      {"nj", "get", "200"}
+    // ]
+
+    CHECK_EQ(2, stats_names.size());
+    return stats_names.size();
+}
+
+} // namespace bar
+} // namespace foo
+```
+
+**使用说明**
+
+一般情况下用户不需要获取labels组合列表，如果有特殊需求，也不建议频繁调用，否则可能影响get_stats的写入性能。
+
+## template
+
+### bvar::Adder
+顾名思义，用于累加
+```c++
+#include <bvar/bvar.h>
+#include <bvar/multi_dimension.h>
+
+namespace foo {
+namespace bar {
+// 定义一个全局的多维度mbvar变量
+bvar::MultiDimension<bvar::Adder<int> > g_request_cost("request_count", {"idc", "method", "status"});
+
+int request_cost_total(const std::list<std::string>& request_labels) {
+    // 获取request对应的单维度mbvar指针，假设request_labels = {"tc", "get", "200"}
+    bvar::Adder<int>* cost_add = g_request_cost.get_stats(request_labels);
+    // 判断指针非空
+    if (!cost_add) {
+        return -1;
+    }
+    // cost_add只能在g_request_cost生命周期内访问，否则行为未定义，可能会出core
+    *cost_add << 1 << 2 << 3 << 4;
+    CHECK_EQ(10, cost_add->get_value());
+    return cost_add->get_value();
+}
+
+} // namespace bar
+} // namespace foo
+```
+
+### bvar::Maxer
+用于取最大值，运算符为std::max
+```c++
+#include <bvar/bvar.h>
+#include <bvar/multi_dimension.h>
+
+namespace foo {
+namespace bar {
+// 定义一个全局的多维度mbvar变量
+bvar::MultiDimension<bvar::Maxer<int> > g_request_cost("request_cost", {"idc", "method", "status"});
+
+int request_cost_max(const std::list<std::string>& request_labels) {
+    // 获取request对应的单维度mbvar指针，假设request_labels = {"tc", "get", "200"}
+    bvar::Maxer<int>* cost_max = g_request_cost.get_stats(request_labels);
+    // 判断指针非空
+    if (!cost_max) {
+        return -1;
+    }
+
+    // cost_max只能在g_request_cost生命周期内访问，否则行为未定义，可能会出core
+    *cost_max << 1 << 2 << 3 << 4;
+    CHECK_EQ(4, cost_max->get_value());
+    return cost_max->get_value();
+}
+
+} // namespace bar
+} // namespace foo
+```
+
+### bvar::Miner
+用于取最小值，运算符为std::min
+```c++
+#include <bvar/bvar.h>
+#include <bvar/multi_dimension.h>
+
+namespace foo {
+namespace bar {
+// 定义一个全局的多维度mbvar变量
+bvar::MultiDimension<bvar::Miner<int> > g_request_cost("request_cost", {"idc", "method", "status"});
+
+int request_cost_min(const std::list<std::string>& request_labels) {
+    // 获取request对应的单维度mbvar指针，假设request_labels = {"tc", "get", "200"}
+    bvar::Miner<int>* cost_min = g_request_cost.get_stats(request_labels);
+    // 判断指针非空
+    if (!cost_min) {
+        return -1;
+    }
+
+    // cost_min只能在g_request_cost生命周期内访问，否则行为未定义，可能会出core
+    *cost_min << 1 << 2 << 3 << 4;
+    CHECK_EQ(1, cost_min->get_value());
+    return cost_min->get_value();
+}
+
+} // namespace bar
+} // namespace foo
+```
+
+### bvar::IntRecorder
+用于计算平均值。
+```c++
+#include <bvar/bvar.h>
+#include <bvar/multi_dimension.h>
+
+namespace foo {
+namespace bar {
+// 定义一个全局的多维度mbvar变量
+bvar::MultiDimension<bvar::IntRecorder> g_request_cost("request_cost", {"idc", "method", "status"});
+
+int request_cost_avg(const std::list<std::string>& request_labels) {
+    // 获取request对应的单维度mbvar指针，假设request_labels = {"tc", "get", "200"}
+    bvar::IntRecorder* cost_avg = g_request_cost.get_stats(request_labels);
+    // 判断指针非空
+    if (!cost_avg) {
+        return -1;
+    }
+
+    // cost_avg只能在g_request_cost生命周期内访问，否则行为未定义，可能会出core
+    *cost_avg << 1 << 3 << 5;
+    CHECK_EQ(3, cost_avg->get_value());
+    return cost_avg->get_value();
+}
+
+} // namespace bar
+} // namespace foo
+```
+
+### bvar::LatencyRecorder
+专用于计算latency和qps的计数器。只需填入latency数据，就能获取latency / max_latency / qps / count，统计窗口是bvar_dump_interval。
+```c++
+#include <bvar/bvar.h>
+#include <bvar/multi_dimension.h>
+
+namespace foo {
+namespace bar {
+// 定义一个全局的多维度mbvar变量
+bvar::MultiDimension<bvar::LatencyRecorder> g_request_cost("request_cost", {"idc", "method", "status"});
+
+void request_cost_latency(const std::list<std::string>& request_labels) {
+    // 获取request对应的单维度mbvar指针，假设request_labels = {"tc", "get", "200"}
+    bvar::LatencyRecorder* cost_latency = g_request_cost.get_stats(request_labels);
+    // 判断指针非空
+    if (!cost_latency) {
+        return -1;
+    }
+
+    // cost_latency只能在g_request_cost生命周期内访问，否则行为未定义，可能会出core
+    *cost_latency << 1 << 2 << 3 << 4 << 5 << 6 << 7;
+
+    // 获取latency
+    int64_t request_cost_latency = cost_latency->latency();
+    // 获取max_latency
+    int64_t request_cost_max_latency = cost_latency->max_latency();
+    // 获取qps
+    int64_t request_cost_qps = cost_latency->qps();
+    // 获取count
+    int64_t request_cost_count = cost_latency->count();
+}
+
+} // namespace bar
+} // namespace foo
+```
+
+### bvar::Status
+记录和显示一个值，拥有额外的set_value函数。
+```c++
+#include <bvar/bvar.h>
+#include <bvar/multi_dimension.h>
+
+namespace foo {
+namespace bar {
+// 定义一个全局的多维度mbvar变量
+bvar::MultiDimension<bvar::Status<int> > g_request_cost("request_cost", {"idc", "method", "status"});
+
+void request_cost(const std::list<std::string>& request_labels) {
+    // 获取request对应的单维度mbvar指针，假设request_labels = {"tc", "get", "200"}
+    bvar::Status<int>* cost_status = g_request_cost.get_stats(request_labels);
+    // 判断指针非空
+    if (!cost_status) {
+        return -1;
+    }
+
+    // cost_status只能在g_request_cost生命周期内访问，否则行为未定义，可能会出core
+    cost_status->set_value(5);
+    CHECK_EQ(5, cost_status->get_value());
+}
+
+} // namespace bar
+} // namespace foo
+```
diff --git a/src/brpc/acceptor.cpp b/src/brpc/acceptor.cpp
index 0e12751..d094ef2 100644
--- a/src/brpc/acceptor.cpp
+++ b/src/brpc/acceptor.cpp
@@ -22,7 +22,7 @@
 #include "butil/fd_utility.h"               // make_close_on_exec
 #include "butil/time.h"                     // gettimeofday_us
 #include "brpc/acceptor.h"
-
+#include "butil/logging.h"
 
 namespace brpc {
 
diff --git a/src/brpc/builtin/bad_method_service.cpp b/src/brpc/builtin/bad_method_service.cpp
index 346b68d..d5c093d 100644
--- a/src/brpc/builtin/bad_method_service.cpp
+++ b/src/brpc/builtin/bad_method_service.cpp
@@ -17,6 +17,7 @@
 
 
 #include <ostream>
+#include <sstream>
 #include <vector>
 #include <google/protobuf/descriptor.h>
 
diff --git a/src/brpc/builtin/dir_service.cpp b/src/brpc/builtin/dir_service.cpp
index 98973b9..06a4a44 100644
--- a/src/brpc/builtin/dir_service.cpp
+++ b/src/brpc/builtin/dir_service.cpp
@@ -26,7 +26,7 @@
 #include "brpc/controller.h"           // Controller
 #include "brpc/builtin/common.h"
 #include "brpc/builtin/dir_service.h"
-
+#include "butil/logging.h"
 
 namespace brpc {
 
diff --git a/src/brpc/builtin/hotspots_service.cpp b/src/brpc/builtin/hotspots_service.cpp
index 9d53881..0909996 100644
--- a/src/brpc/builtin/hotspots_service.cpp
+++ b/src/brpc/builtin/hotspots_service.cpp
@@ -23,6 +23,7 @@
 #include "butil/file_util.h"                     // butil::FilePath
 #include "butil/popen.h"                         // butil::read_command_output
 #include "butil/fd_guard.h"                      // butil::fd_guard
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/controller.h"
 #include "brpc/server.h"
diff --git a/src/brpc/builtin/index_service.cpp b/src/brpc/builtin/index_service.cpp
index f067b55..ecdc1c4 100644
--- a/src/brpc/builtin/index_service.cpp
+++ b/src/brpc/builtin/index_service.cpp
@@ -15,7 +15,7 @@
 // specific language governing permissions and limitations
 // under the License.
 
-
+#include <sstream>
 #include <gflags/gflags.h>                  // DECLARE_xxx
 #include <google/protobuf/descriptor.h>
 #include "butil/time.h"                      // gettimeofday_us
diff --git a/src/brpc/builtin/pprof_service.cpp b/src/brpc/builtin/pprof_service.cpp
index abc2b8e..64b2d3f 100644
--- a/src/brpc/builtin/pprof_service.cpp
+++ b/src/brpc/builtin/pprof_service.cpp
@@ -28,6 +28,7 @@
 #include "butil/time.h"
 #include "butil/popen.h"                    // butil::read_command_output
 #include "butil/process_util.h"             // butil::ReadCommandLine
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/controller.h"                // Controller
 #include "brpc/closure_guard.h"             // ClosureGuard
diff --git a/src/brpc/builtin/prometheus_metrics_service.cpp b/src/brpc/builtin/prometheus_metrics_service.cpp
index 5eddb1a..dc31b86 100644
--- a/src/brpc/builtin/prometheus_metrics_service.cpp
+++ b/src/brpc/builtin/prometheus_metrics_service.cpp
@@ -25,6 +25,8 @@
 #include "brpc/builtin/prometheus_metrics_service.h"
 #include "brpc/builtin/common.h"
 #include "bvar/bvar.h"
+#include "butil/logging.h"
+#include "bvar/mvariable.h"
 
 namespace bvar {
 DECLARE_int32(bvar_latency_p1);
@@ -53,6 +55,7 @@ public:
     }
 
     bool dump(const std::string& name, const butil::StringPiece& desc) override;
+    size_t dumps(const std::vector<std::pair<std::string, std::string>>& v) override;
 
 private:
     DISALLOW_COPY_AND_ASSIGN(PrometheusMetricsDumper);
@@ -98,6 +101,29 @@ bool PrometheusMetricsDumper::dump(const std::string& name,
     return true;
 }
 
+size_t PrometheusMetricsDumper::dumps(const std::vector<std::pair<std::string, std::string>>& v) {
+    size_t n = 0;
+    for (size_t i = 0;i < v.size(); i++) {
+        bool first = (i == 0);
+        auto& vi = v[i];
+
+        if (!vi.second.empty() && vi.second[0] == '"') {
+            // there is no necessary to monitor string in prometheus
+            continue;
+        }
+
+        if (first) {
+            auto pos = vi.first.find('{');
+            auto name = vi.first.substr(pos);
+            *_os << "# HELP " << name << '\n'
+                 << "# TYPE " << name << " gauge" << '\n';
+        }
+        *_os << vi.first << " " << vi.second << '\n';
+        n++;
+    }
+    return n;
+}
+
 const PrometheusMetricsDumper::SummaryItems*
 PrometheusMetricsDumper::ProcessLatencyRecorderSuffix(const butil::StringPiece& name,
                                                       const butil::StringPiece& desc) {
@@ -154,6 +180,7 @@ bool PrometheusMetricsDumper::DumpLatencyRecorderSuffix(
     if (!si->IsComplete()) {
         return true;
     }
+
     *_os << "# HELP " << si->metric_name << '\n'
          << "# TYPE " << si->metric_name << " summary\n"
          << si->metric_name << "{quantile=\""
@@ -195,7 +222,12 @@ void PrometheusMetricsService::default_method(::google::protobuf::RpcController*
 int DumpPrometheusMetricsToIOBuf(butil::IOBuf* output) {
     butil::IOBufBuilder os;
     PrometheusMetricsDumper dumper(&os, g_server_info_prefix);
-    const int ndump = bvar::Variable::dump_exposed(&dumper, NULL);
+    int ndump = bvar::Variable::dump_exposed(&dumper, NULL);
+    if (ndump < 0) {
+        return -1;
+    }
+
+    ndump = bvar::MVariable::dump_exposed(&dumper, NULL);
     if (ndump < 0) {
         return -1;
     }
diff --git a/src/brpc/builtin/protobufs_service.cpp b/src/brpc/builtin/protobufs_service.cpp
index 2344e46..a3ec5c4 100644
--- a/src/brpc/builtin/protobufs_service.cpp
+++ b/src/brpc/builtin/protobufs_service.cpp
@@ -23,7 +23,7 @@
 #include "brpc/details/method_status.h"// MethodStatus
 #include "brpc/builtin/protobufs_service.h"
 #include "brpc/builtin/common.h"
-
+#include "butil/logging.h"
 
 namespace brpc {
 
diff --git a/src/brpc/builtin/rpcz_service.cpp b/src/brpc/builtin/rpcz_service.cpp
index d4374e4..66c7afe 100644
--- a/src/brpc/builtin/rpcz_service.cpp
+++ b/src/brpc/builtin/rpcz_service.cpp
@@ -23,6 +23,7 @@
 #include "butil/string_splitter.h"
 #include "butil/macros.h"
 #include "butil/time.h"
+#include "butil/logging.h"
 #include "brpc/closure_guard.h"        // ClosureGuard
 #include "brpc/controller.h"           // Controller
 #include "brpc/builtin/common.h"
diff --git a/src/brpc/builtin/status_service.cpp b/src/brpc/builtin/status_service.cpp
index 0a2ca7c..dfc2f69 100644
--- a/src/brpc/builtin/status_service.cpp
+++ b/src/brpc/builtin/status_service.cpp
@@ -29,7 +29,7 @@
 #endif
 #include "brpc/rtmp.h"                 // RtmpService
 #include "brpc/builtin/common.h"
-
+#include "butil/logging.h"
 
 namespace brpc {
 namespace policy {
diff --git a/src/brpc/builtin/threads_service.cpp b/src/brpc/builtin/threads_service.cpp
index 458c1c3..16224da 100644
--- a/src/brpc/builtin/threads_service.cpp
+++ b/src/brpc/builtin/threads_service.cpp
@@ -24,6 +24,7 @@
 #include "brpc/builtin/threads_service.h"
 #include "brpc/builtin/common.h"
 #include "butil/string_printf.h"
+#include "butil/logging.h"
 
 namespace brpc {
 
diff --git a/src/brpc/builtin/vars_service.cpp b/src/brpc/builtin/vars_service.cpp
index f60c49f..7d53b45 100644
--- a/src/brpc/builtin/vars_service.cpp
+++ b/src/brpc/builtin/vars_service.cpp
@@ -27,6 +27,7 @@
 #include "brpc/server.h"
 #include "brpc/builtin/common.h"
 #include "brpc/builtin/vars_service.h"
+#include "bvar/mvariable.h"
 
 namespace bvar {
 DECLARE_bool(quote_vector);
@@ -413,11 +414,16 @@ void VarsService::default_method(::google::protobuf::RpcController* cntl_base,
     options.display_filter = 
         (use_html ? bvar::DISPLAY_ON_HTML : bvar::DISPLAY_ON_PLAIN_TEXT);
     options.white_wildcards = cntl->http_request().unresolved_path();
-    const int ndump = bvar::Variable::dump_exposed(&dumper, &options);
+    int ndump = bvar::Variable::dump_exposed(&dumper, &options);
     if (ndump < 0) {
         cntl->SetFailed("Fail to dump vars");
         return;
     }
+    ndump = bvar::MVariable::dump_exposed(&dumper, &options);
+    if (ndump < 0) {
+        cntl->SetFailed("Fail to dump multi dimension vars");
+        return;
+    }
     if (!options.white_wildcards.empty() && ndump == 0) {
         cntl->SetFailed(ENOMETHOD, "Fail to find any bvar by `%s'",
                         options.white_wildcards.c_str());
diff --git a/src/brpc/builtin/vlog_service.cpp b/src/brpc/builtin/vlog_service.cpp
index 2980d0b..1490c17 100644
--- a/src/brpc/builtin/vlog_service.cpp
+++ b/src/brpc/builtin/vlog_service.cpp
@@ -18,6 +18,7 @@
 
 #if !BRPC_WITH_GLOG
 
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/controller.h"           // Controller
 #include "brpc/closure_guard.h"        // ClosureGuard
diff --git a/src/brpc/channel_base.h b/src/brpc/channel_base.h
index ed6ff24..132dd8f 100644
--- a/src/brpc/channel_base.h
+++ b/src/brpc/channel_base.h
@@ -21,7 +21,7 @@
 
 #include <stdlib.h>
 #include <ostream>
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include <google/protobuf/service.h>            // google::protobuf::RpcChannel
 #include "brpc/describable.h"
 
@@ -36,7 +36,7 @@ class ChannelBase : public google::protobuf::RpcChannel/*non-copyable*/,
                     public Describable {
 public:
     virtual int Weight() {
-        CHECK(false) << "Not implemented";
+        //CHECK(false) << "Not implemented";
         abort();
     };
 
diff --git a/src/brpc/cluster_recover_policy.cpp b/src/brpc/cluster_recover_policy.cpp
index d1338f6..1c32a18 100644
--- a/src/brpc/cluster_recover_policy.cpp
+++ b/src/brpc/cluster_recover_policy.cpp
@@ -25,6 +25,7 @@
 #include "brpc/socket.h"
 #include "butil/fast_rand.h"
 #include "butil/time.h"
+#include "butil/logging.h"
 #include "butil/string_splitter.h"
 
 namespace brpc {
diff --git a/src/brpc/controller.h b/src/brpc/controller.h
index e4e3533..c1ddd17 100755
--- a/src/brpc/controller.h
+++ b/src/brpc/controller.h
@@ -28,6 +28,7 @@
 #include "bthread/errno.h"                     // Redefine errno
 #include "butil/endpoint.h"                    // butil::EndPoint
 #include "butil/iobuf.h"                       // butil::IOBuf
+#include "butil/time.h"                        // butil::cpuwide_time_us
 #include "bthread/types.h"                     // bthread_id_t
 #include "brpc/options.pb.h"                   // CompressType
 #include "brpc/errno.pb.h"                     // error code
diff --git a/src/brpc/details/controller_private_accessor.h b/src/brpc/details/controller_private_accessor.h
index 362c8f0..7319f19 100644
--- a/src/brpc/details/controller_private_accessor.h
+++ b/src/brpc/details/controller_private_accessor.h
@@ -58,7 +58,7 @@ public:
     }
 
     void move_in_server_receiving_sock(SocketUniquePtr& ptr) {
-        CHECK(_cntl->_current_call.sending_sock == NULL);
+        //CHECK(_cntl->_current_call.sending_sock == NULL);
         _cntl->_current_call.sending_sock.reset(ptr.release());
     }
 
diff --git a/src/brpc/details/health_check.cpp b/src/brpc/details/health_check.cpp
index 6cb5f47..923411a 100644
--- a/src/brpc/details/health_check.cpp
+++ b/src/brpc/details/health_check.cpp
@@ -22,6 +22,7 @@
 #include "brpc/controller.h"
 #include "brpc/details/controller_private_accessor.h"
 #include "brpc/global.h"
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "bthread/unstable.h"
 #include "bthread/bthread.h"
diff --git a/src/brpc/details/hpack.cpp b/src/brpc/details/hpack.cpp
index 43a2d9e..7878b50 100644
--- a/src/brpc/details/hpack.cpp
+++ b/src/brpc/details/hpack.cpp
@@ -24,7 +24,7 @@
 #include "butil/containers/flat_map.h"                   // butil::FlatMap
 #include "butil/containers/case_ignored_flat_map.h"      // butil::FlatMap
 #include "brpc/details/hpack-static-table.h"       // s_static_headers
-
+#include "butil/logging.h"
 
 namespace brpc {
 
diff --git a/src/brpc/details/http_message.cpp b/src/brpc/details/http_message.cpp
index d9c590c..130f640 100644
--- a/src/brpc/details/http_message.cpp
+++ b/src/brpc/details/http_message.cpp
@@ -27,6 +27,7 @@
 #include "butil/endpoint.h"
 #include "butil/base64.h"
 #include "bthread/bthread.h"                    // bthread_usleep
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/reloadable_flags.h"
 #include "brpc/details/http_message.h"
diff --git a/src/brpc/details/load_balancer_with_naming.cpp b/src/brpc/details/load_balancer_with_naming.cpp
index 2fad84b..e6733ba 100644
--- a/src/brpc/details/load_balancer_with_naming.cpp
+++ b/src/brpc/details/load_balancer_with_naming.cpp
@@ -17,7 +17,7 @@
 
 
 #include "brpc/details/load_balancer_with_naming.h"
-
+#include "butil/logging.h"
 
 namespace brpc {
 
diff --git a/src/brpc/details/server_private_accessor.h b/src/brpc/details/server_private_accessor.h
index aacf283..c2d84dd 100644
--- a/src/brpc/details/server_private_accessor.h
+++ b/src/brpc/details/server_private_accessor.h
@@ -32,7 +32,7 @@ namespace brpc {
 class ServerPrivateAccessor {
 public:
     explicit ServerPrivateAccessor(const Server* svr) {
-        CHECK(svr);
+        //CHECK(svr);
         _server = svr;
     }
 
diff --git a/src/brpc/details/sparse_minute_counter.h b/src/brpc/details/sparse_minute_counter.h
index 3834afa..fba627b 100644
--- a/src/brpc/details/sparse_minute_counter.h
+++ b/src/brpc/details/sparse_minute_counter.h
@@ -131,7 +131,7 @@ void SparseMinuteCounter<T>::DestroyQueue(Q* q) {
 
 template <typename T>
 void SparseMinuteCounter<T>::Resize() {
-    CHECK_LT(_q->capacity(), (size_t)60);
+    //CHECK_LT(_q->capacity(), (size_t)60);
     uint32_t new_cap = std::min(2 * (uint32_t)_q->capacity(), 60u);
     Q* new_q = CreateQueue(new_cap);
     for (size_t i = 0; i < _q->size(); ++i) {
diff --git a/src/brpc/details/usercode_backup_pool.cpp b/src/brpc/details/usercode_backup_pool.cpp
index 53a1541..d0131de 100644
--- a/src/brpc/details/usercode_backup_pool.cpp
+++ b/src/brpc/details/usercode_backup_pool.cpp
@@ -24,6 +24,7 @@
 #include "butil/comlog_sink.h"
 #endif
 #include "brpc/details/usercode_backup_pool.h"
+#include "butil/logging.h"
 
 namespace bthread {
 // Defined in bthread/task_control.cpp
diff --git a/src/brpc/esp_message.h b/src/brpc/esp_message.h
index 1b23974..377b170 100644
--- a/src/brpc/esp_message.h
+++ b/src/brpc/esp_message.h
@@ -54,6 +54,13 @@ public:
     // implements Message ----------------------------------------------
 
     EspMessage* New() const;
+    EspMessage* New(::google::protobuf::Arena* arena) const {
+        EspMessage* message = New();
+        if (arena != nullptr) {
+            arena->Own(message);
+        }
+        return message;
+    }
     void CopyFrom(const ::google::protobuf::Message& from);
     void MergeFrom(const ::google::protobuf::Message& from);
     void CopyFrom(const EspMessage& from);
diff --git a/src/brpc/extension.h b/src/brpc/extension.h
index 9d6c94b..343a73f 100644
--- a/src/brpc/extension.h
+++ b/src/brpc/extension.h
@@ -21,7 +21,7 @@
 
 #include <string>
 #include "butil/scoped_lock.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "butil/containers/case_ignored_flat_map.h"
 #include "butil/memory/singleton_on_pthread_once.h"
 
diff --git a/src/brpc/extension_inl.h b/src/brpc/extension_inl.h
index 8eede30..8b1a1c6 100644
--- a/src/brpc/extension_inl.h
+++ b/src/brpc/extension_inl.h
@@ -41,12 +41,12 @@ Extension<T>::~Extension() {
 template <typename T>
 int Extension<T>::Register(const std::string& name, T* instance) {
     if (NULL == instance) {
-        LOG(ERROR) << "instance to \"" << name << "\" is NULL";
+        //LOG(ERROR) << "instance to \"" << name << "\" is NULL";
         return -1;
     }
     BAIDU_SCOPED_LOCK(_map_mutex);
     if (_instance_map.seek(name) != NULL) {
-        LOG(ERROR) << "\"" << name << "\" was registered";
+        //LOG(ERROR) << "\"" << name << "\" was registered";
         return -1;
     }
     _instance_map[name] = instance;
diff --git a/src/brpc/load_balancer.cpp b/src/brpc/load_balancer.cpp
index 18f6a7a..6e6d255 100644
--- a/src/brpc/load_balancer.cpp
+++ b/src/brpc/load_balancer.cpp
@@ -19,7 +19,7 @@
 #include <gflags/gflags.h>
 #include "brpc/reloadable_flags.h"
 #include "brpc/load_balancer.h"
-
+#include "butil/logging.h"
 
 namespace brpc {
 
diff --git a/src/brpc/memcache.h b/src/brpc/memcache.h
index bd54c39..9854fad 100644
--- a/src/brpc/memcache.h
+++ b/src/brpc/memcache.h
@@ -90,6 +90,13 @@ public:
 
     // Protobuf methods.
     MemcacheRequest* New() const;
+    MemcacheRequest* New(::google::protobuf::Arena* arena) const {
+        MemcacheRequest* message = New();
+        if (arena != nullptr) {
+            arena->Own(message);
+        }
+        return message;
+    }
     void CopyFrom(const ::google::protobuf::Message& from);
     void MergeFrom(const ::google::protobuf::Message& from);
     void CopyFrom(const MemcacheRequest& from);
@@ -200,6 +207,13 @@ public:
     // implements Message ----------------------------------------------
   
     MemcacheResponse* New() const;
+    MemcacheResponse* New(::google::protobuf::Arena* arena) const {
+        MemcacheResponse* message = New();
+        if (arena != nullptr) {
+            arena->Own(message);
+        }
+        return message;
+    }
     void CopyFrom(const ::google::protobuf::Message& from);
     void MergeFrom(const ::google::protobuf::Message& from);
     void CopyFrom(const MemcacheResponse& from);
diff --git a/src/brpc/nshead_message.h b/src/brpc/nshead_message.h
index 3f41454..20cbab8 100644
--- a/src/brpc/nshead_message.h
+++ b/src/brpc/nshead_message.h
@@ -50,6 +50,13 @@ public:
     // implements Message ----------------------------------------------
   
     NsheadMessage* New() const;
+    NsheadMessage* New(::google::protobuf::Arena* arena) const {
+        NsheadMessage* message = New();
+        if (arena != nullptr) {
+            arena->Own(message);
+        }
+        return message;
+    }
     void CopyFrom(const ::google::protobuf::Message& from);
     void MergeFrom(const ::google::protobuf::Message& from);
     void CopyFrom(const NsheadMessage& from);
diff --git a/src/brpc/nshead_service.cpp b/src/brpc/nshead_service.cpp
index 0f043e2..0dca955 100644
--- a/src/brpc/nshead_service.cpp
+++ b/src/brpc/nshead_service.cpp
@@ -19,7 +19,7 @@
 #include "butil/class_name.h"
 #include "brpc/nshead_service.h"
 #include "brpc/details/method_status.h"
-
+#include "butil/logging.h"
 
 namespace brpc {
 
diff --git a/src/brpc/parallel_channel.cpp b/src/brpc/parallel_channel.cpp
index cf92e71..c21b29d 100644
--- a/src/brpc/parallel_channel.cpp
+++ b/src/brpc/parallel_channel.cpp
@@ -23,7 +23,7 @@
 #include "butil/macros.h"
 #include "brpc/details/controller_private_accessor.h"
 #include "brpc/parallel_channel.h"
-
+#include "butil/logging.h"
 
 namespace brpc {
 
diff --git a/src/brpc/partition_channel.cpp b/src/brpc/partition_channel.cpp
index c15fddd..455c919 100644
--- a/src/brpc/partition_channel.cpp
+++ b/src/brpc/partition_channel.cpp
@@ -17,6 +17,7 @@
 
 
 #include "butil/containers/flat_map.h"
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/load_balancer.h"
 #include "brpc/details/naming_service_thread.h"
diff --git a/src/brpc/periodic_task.cpp b/src/brpc/periodic_task.cpp
index 27ea3ec..23804e4 100644
--- a/src/brpc/periodic_task.cpp
+++ b/src/brpc/periodic_task.cpp
@@ -19,6 +19,7 @@
 #include <bthread/bthread.h>
 #include <bthread/unstable.h>
 #include "brpc/periodic_task.h"
+#include "butil/logging.h"
 
 namespace brpc {
 
diff --git a/src/brpc/policy/auto_concurrency_limiter.cpp b/src/brpc/policy/auto_concurrency_limiter.cpp
index 5eafbd7..7707f92 100644
--- a/src/brpc/policy/auto_concurrency_limiter.cpp
+++ b/src/brpc/policy/auto_concurrency_limiter.cpp
@@ -19,6 +19,7 @@
 #include <gflags/gflags.h>
 #include "brpc/errno.pb.h"
 #include "brpc/policy/auto_concurrency_limiter.h"
+#include "butil/logging.h"
 
 namespace bthread {
 
diff --git a/src/brpc/policy/consistent_hashing_load_balancer.cpp b/src/brpc/policy/consistent_hashing_load_balancer.cpp
index fd22380..07ba6da 100644
--- a/src/brpc/policy/consistent_hashing_load_balancer.cpp
+++ b/src/brpc/policy/consistent_hashing_load_balancer.cpp
@@ -21,6 +21,7 @@
 #include <gflags/gflags.h>
 #include "butil/containers/flat_map.h"
 #include "butil/errno.h"
+#include "butil/logging.h"
 #include "butil/strings/string_number_conversions.h"
 #include "brpc/socket.h"
 #include "brpc/policy/consistent_hashing_load_balancer.h"
diff --git a/src/brpc/policy/constant_concurrency_limiter.cpp b/src/brpc/policy/constant_concurrency_limiter.cpp
index 91ab7a8..876a0ec 100644
--- a/src/brpc/policy/constant_concurrency_limiter.cpp
+++ b/src/brpc/policy/constant_concurrency_limiter.cpp
@@ -16,6 +16,7 @@
 // under the License.
 
 #include "brpc/policy/constant_concurrency_limiter.h"
+#include "butil/logging.h"
 
 namespace brpc {
 namespace policy {
diff --git a/src/brpc/policy/consul_naming_service.cpp b/src/brpc/policy/consul_naming_service.cpp
index f4b2345..bf05d45 100644
--- a/src/brpc/policy/consul_naming_service.cpp
+++ b/src/brpc/policy/consul_naming_service.cpp
@@ -25,6 +25,7 @@
 #include "butil/third_party/rapidjson/prettywriter.h"
 #include "butil/time/time.h"
 #include "bthread/bthread.h"
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/channel.h"
 #include "brpc/policy/file_naming_service.h"
diff --git a/src/brpc/policy/discovery_naming_service.cpp b/src/brpc/policy/discovery_naming_service.cpp
index a6caf4d..fca55d1 100644
--- a/src/brpc/policy/discovery_naming_service.cpp
+++ b/src/brpc/policy/discovery_naming_service.cpp
@@ -23,6 +23,7 @@
 #include "butil/string_printf.h"
 #include "butil/strings/string_split.h"
 #include "butil/fast_rand.h"
+#include "butil/logging.h"
 #include "bthread/bthread.h"
 #include "brpc/channel.h"
 #include "brpc/controller.h"
diff --git a/src/brpc/policy/domain_naming_service.cpp b/src/brpc/policy/domain_naming_service.cpp
index 6e1d975..32aebc7 100644
--- a/src/brpc/policy/domain_naming_service.cpp
+++ b/src/brpc/policy/domain_naming_service.cpp
@@ -21,6 +21,7 @@
 #include <stdlib.h>                                   // strtol
 #include <string>                                     // std::string
 #include "bthread/bthread.h"
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/policy/domain_naming_service.h"
 
diff --git a/src/brpc/policy/dynpart_load_balancer.cpp b/src/brpc/policy/dynpart_load_balancer.cpp
index 4785a0f..193394b 100644
--- a/src/brpc/policy/dynpart_load_balancer.cpp
+++ b/src/brpc/policy/dynpart_load_balancer.cpp
@@ -18,6 +18,7 @@
 
 #include "butil/macros.h"
 #include "butil/fast_rand.h"
+#include "butil/logging.h"
 #include "brpc/socket.h"
 #include "brpc/policy/dynpart_load_balancer.h"
 
diff --git a/src/brpc/policy/esp_protocol.cpp b/src/brpc/policy/esp_protocol.cpp
index 6665a1a..c7edb38 100644
--- a/src/brpc/policy/esp_protocol.cpp
+++ b/src/brpc/policy/esp_protocol.cpp
@@ -19,7 +19,8 @@
 #include <google/protobuf/message.h>            // Message
 #include <gflags/gflags.h>
 
-#include "butil/time.h" 
+#include "butil/time.h"
+#include "butil/logging.h"
 #include "butil/iobuf.h"                         // butil::IOBuf
 
 #include "brpc/controller.h"               // Controller
diff --git a/src/brpc/policy/file_naming_service.cpp b/src/brpc/policy/file_naming_service.cpp
index df49673..9a32aba 100644
--- a/src/brpc/policy/file_naming_service.cpp
+++ b/src/brpc/policy/file_naming_service.cpp
@@ -22,6 +22,7 @@
 #include "butil/files/file_watcher.h"                    // FileWatcher
 #include "butil/files/scoped_file.h"                     // ScopedFILE
 #include "bthread/bthread.h"                            // bthread_usleep
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/policy/file_naming_service.h"
 
diff --git a/src/brpc/policy/http2_rpc_protocol.cpp b/src/brpc/policy/http2_rpc_protocol.cpp
index a5e89d0..1cfc482 100644
--- a/src/brpc/policy/http2_rpc_protocol.cpp
+++ b/src/brpc/policy/http2_rpc_protocol.cpp
@@ -20,6 +20,7 @@
 #include "brpc/details/controller_private_accessor.h"
 #include "brpc/server.h"
 #include "butil/base64.h"
+#include "butil/logging.h"
 #include "brpc/log.h"
 
 namespace brpc {
diff --git a/src/brpc/policy/http2_rpc_protocol.h b/src/brpc/policy/http2_rpc_protocol.h
index 8574723..f185569 100644
--- a/src/brpc/policy/http2_rpc_protocol.h
+++ b/src/brpc/policy/http2_rpc_protocol.h
@@ -399,8 +399,8 @@ friend void InitFrameHandlers();
 
 inline int H2Context::AllocateClientStreamId() {
     if (RunOutStreams()) {
-        LOG(WARNING) << "Fail to allocate new client stream, _last_sent_stream_id="
-            << _last_sent_stream_id;
+        //LOG(WARNING) << "Fail to allocate new client stream, _last_sent_stream_id="
+        //    << _last_sent_stream_id;
         return -1;
     }
     const int id = _last_sent_stream_id;
diff --git a/src/brpc/policy/http_rpc_protocol.cpp b/src/brpc/policy/http_rpc_protocol.cpp
index 7bd06ec..bce5b7d 100644
--- a/src/brpc/policy/http_rpc_protocol.cpp
+++ b/src/brpc/policy/http_rpc_protocol.cpp
@@ -27,6 +27,7 @@
 #include "butil/string_printf.h"
 #include "butil/time.h"
 #include "butil/sys_byteorder.h"
+#include "butil/logging.h"
 #include "brpc/compress.h"
 #include "brpc/errno.pb.h"                     // ENOSERVICE, ENOMETHOD
 #include "brpc/controller.h"                   // Controller
@@ -758,16 +759,9 @@ HttpResponseSender::~HttpResponseSender() {
                 cntl->SetFailed(ERESPONSE, "Fail to serialize %s", res->GetTypeName().c_str());
             }
         } else {
-            std::string err;
-            json2pb::Pb2JsonOptions opt;
-            opt.bytes_to_base64 = cntl->has_pb_bytes_to_base64();
-            opt.jsonify_empty_array = cntl->has_pb_jsonify_empty_array();
-            opt.always_print_primitive_fields = cntl->has_always_print_primitive_fields();
-            opt.enum_option = (FLAGS_pb_enum_as_number
-                               ? json2pb::OUTPUT_ENUM_BY_NUMBER
-                               : json2pb::OUTPUT_ENUM_BY_NAME);
-            if (!json2pb::ProtoMessageToJson(*res, &wrapper, opt, &err)) {
-                cntl->SetFailed(ERESPONSE, "Fail to convert response to json, %s", err.c_str());
+            auto status = json2pb::ProtoMessageToJsonWithWellKnownType(*res, &wrapper);
+            if (!status.ok()) {
+                cntl->SetFailed(ERESPONSE, "Fail to convert response to json, %s", status.message().data());
             }
         }
     }
diff --git a/src/brpc/policy/hulu_pbrpc_protocol.cpp b/src/brpc/policy/hulu_pbrpc_protocol.cpp
index 50660a0..969eab9 100644
--- a/src/brpc/policy/hulu_pbrpc_protocol.cpp
+++ b/src/brpc/policy/hulu_pbrpc_protocol.cpp
@@ -21,6 +21,7 @@
 #include <google/protobuf/io/zero_copy_stream_impl_lite.h>
 #include <google/protobuf/io/coded_stream.h>
 #include "butil/time.h"
+#include "butil/logging.h"
 #include "brpc/controller.h"                     // Controller
 #include "brpc/socket.h"                         // Socket
 #include "brpc/server.h"                         // Server
diff --git a/src/brpc/policy/list_naming_service.cpp b/src/brpc/policy/list_naming_service.cpp
index 3a8ba45..bfba842 100644
--- a/src/brpc/policy/list_naming_service.cpp
+++ b/src/brpc/policy/list_naming_service.cpp
@@ -20,6 +20,7 @@
 #include <string>                                     // std::string
 #include <set>                                        // std::set
 #include "butil/string_splitter.h"                     // StringSplitter
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/policy/list_naming_service.h"
 
diff --git a/src/brpc/policy/locality_aware_load_balancer.cpp b/src/brpc/policy/locality_aware_load_balancer.cpp
index db13982..74ff23b 100644
--- a/src/brpc/policy/locality_aware_load_balancer.cpp
+++ b/src/brpc/policy/locality_aware_load_balancer.cpp
@@ -20,6 +20,7 @@
 #include <gflags/gflags.h>
 #include "butil/time.h"                                       // gettimeofday_us
 #include "butil/fast_rand.h"
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/socket.h"
 #include "brpc/reloadable_flags.h"
diff --git a/src/brpc/policy/locality_aware_load_balancer.h b/src/brpc/policy/locality_aware_load_balancer.h
index f4392f4..cb542c0 100644
--- a/src/brpc/policy/locality_aware_load_balancer.h
+++ b/src/brpc/policy/locality_aware_load_balancer.h
@@ -118,7 +118,7 @@ private:
         butil::FlatMap<SocketId, size_t> server_map;
 
         Servers() {
-            CHECK_EQ(0, server_map.init(1024, 70));
+            server_map.init(1024, 70);
         }
 
         // Add diff to left_weight of all parent nodes of node `index'.
diff --git a/src/brpc/policy/mongo_protocol.cpp b/src/brpc/policy/mongo_protocol.cpp
index 82bb3e0..74d9ecf 100644
--- a/src/brpc/policy/mongo_protocol.cpp
+++ b/src/brpc/policy/mongo_protocol.cpp
@@ -18,7 +18,8 @@
 #include <google/protobuf/descriptor.h>         // MethodDescriptor
 #include <google/protobuf/message.h>            // Message
 #include <gflags/gflags.h>
-#include "butil/time.h" 
+#include "butil/time.h"
+#include "butil/logging.h"
 #include "butil/iobuf.h"                         // butil::IOBuf
 #include "brpc/controller.h"               // Controller
 #include "brpc/socket.h"                   // Socket
diff --git a/src/brpc/policy/nova_pbrpc_protocol.cpp b/src/brpc/policy/nova_pbrpc_protocol.cpp
index e21b312..aace18c 100644
--- a/src/brpc/policy/nova_pbrpc_protocol.cpp
+++ b/src/brpc/policy/nova_pbrpc_protocol.cpp
@@ -22,6 +22,7 @@
 
 #include "butil/time.h"
 #include "butil/iobuf.h"                        // butil::IOBuf
+#include "butil/logging.h"
 
 #include "brpc/controller.h"               // Controller
 #include "brpc/socket.h"                   // Socket
diff --git a/src/brpc/policy/nshead_protocol.cpp b/src/brpc/policy/nshead_protocol.cpp
index 1c2186b..09f1903 100644
--- a/src/brpc/policy/nshead_protocol.cpp
+++ b/src/brpc/policy/nshead_protocol.cpp
@@ -21,6 +21,7 @@
 #include <gflags/gflags.h>
 #include "butil/time.h" 
 #include "butil/iobuf.h"                         // butil::IOBuf
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/controller.h"               // Controller
 #include "brpc/socket.h"                   // Socket
diff --git a/src/brpc/policy/public_pbrpc_protocol.cpp b/src/brpc/policy/public_pbrpc_protocol.cpp
index d1bc832..06c2f7a 100644
--- a/src/brpc/policy/public_pbrpc_protocol.cpp
+++ b/src/brpc/policy/public_pbrpc_protocol.cpp
@@ -21,6 +21,7 @@
 #include <gflags/gflags.h>
 #include "butil/third_party/snappy/snappy.h"        // snappy::Compress
 #include "butil/time.h"
+#include "butil/logging.h"
 #include "brpc/controller.h"                       // Controller
 #include "brpc/socket.h"                           // Socket
 #include "brpc/server.h"                           // Server
diff --git a/src/brpc/policy/randomized_load_balancer.cpp b/src/brpc/policy/randomized_load_balancer.cpp
index cac695a..517ad8b 100644
--- a/src/brpc/policy/randomized_load_balancer.cpp
+++ b/src/brpc/policy/randomized_load_balancer.cpp
@@ -18,6 +18,7 @@
 
 #include "butil/macros.h"
 #include "butil/fast_rand.h"
+#include "butil/logging.h"
 #include "brpc/socket.h"
 #include "brpc/policy/randomized_load_balancer.h"
 #include "butil/strings/string_number_conversions.h"
diff --git a/src/brpc/policy/remote_file_naming_service.cpp b/src/brpc/policy/remote_file_naming_service.cpp
index c5aeac9..be20126 100644
--- a/src/brpc/policy/remote_file_naming_service.cpp
+++ b/src/brpc/policy/remote_file_naming_service.cpp
@@ -22,6 +22,7 @@
 #include <set>                                          // std::set
 #include "bthread/bthread.h"                            // bthread_usleep
 #include "butil/iobuf.h"
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/channel.h"
 #include "brpc/policy/remote_file_naming_service.h"
diff --git a/src/brpc/policy/round_robin_load_balancer.cpp b/src/brpc/policy/round_robin_load_balancer.cpp
index ee7fa53..4d562af 100644
--- a/src/brpc/policy/round_robin_load_balancer.cpp
+++ b/src/brpc/policy/round_robin_load_balancer.cpp
@@ -18,6 +18,7 @@
 
 #include "butil/macros.h"
 #include "butil/fast_rand.h"
+#include "butil/logging.h"
 #include "brpc/socket.h"
 #include "brpc/policy/round_robin_load_balancer.h"
 
diff --git a/src/brpc/policy/rtmp_protocol.cpp b/src/brpc/policy/rtmp_protocol.cpp
index 33a0c0c..84066b3 100644
--- a/src/brpc/policy/rtmp_protocol.cpp
+++ b/src/brpc/policy/rtmp_protocol.cpp
@@ -21,6 +21,7 @@
 #include "butil/scoped_lock.h"
 #include "butil/fast_rand.h"
 #include "butil/sys_byteorder.h"
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/server.h"
 #include "brpc/details/controller_private_accessor.h"
diff --git a/src/brpc/policy/rtmp_protocol.h b/src/brpc/policy/rtmp_protocol.h
index b5572c2..1a88d08 100644
--- a/src/brpc/policy/rtmp_protocol.h
+++ b/src/brpc/policy/rtmp_protocol.h
@@ -608,7 +608,7 @@ inline void WriteBigEndian2Bytes(char** buf, uint16_t val) {
 }
 inline void WriteBigEndian3Bytes(char** buf, uint32_t val) {
     const char* p = (const char*)&val;
-    CHECK_EQ(p[3], 0);
+    //CHECK_EQ(p[3], 0);
     char* out = *buf;
     out[0] = p[2];
     out[1] = p[1];
diff --git a/src/brpc/policy/sofa_pbrpc_protocol.cpp b/src/brpc/policy/sofa_pbrpc_protocol.cpp
index 27d8037..33f09b7 100644
--- a/src/brpc/policy/sofa_pbrpc_protocol.cpp
+++ b/src/brpc/policy/sofa_pbrpc_protocol.cpp
@@ -21,6 +21,7 @@
 #include <google/protobuf/io/zero_copy_stream_impl_lite.h>
 #include <google/protobuf/io/coded_stream.h>
 #include "butil/time.h"
+#include "butil/logging.h"
 #include "brpc/controller.h"                // Controller
 #include "brpc/socket.h"                    // Socket
 #include "brpc/server.h"                    // Server
diff --git a/src/brpc/policy/thrift_protocol.cpp b/src/brpc/policy/thrift_protocol.cpp
index eae081a..124b2ed 100755
--- a/src/brpc/policy/thrift_protocol.cpp
+++ b/src/brpc/policy/thrift_protocol.cpp
@@ -22,6 +22,7 @@
 
 #include "butil/time.h" 
 #include "butil/iobuf.h"                        // butil::IOBuf
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/controller.h"                    // Controller
 #include "brpc/socket.h"                        // Socket
diff --git a/src/brpc/policy/weighted_randomized_load_balancer.cpp b/src/brpc/policy/weighted_randomized_load_balancer.cpp
index 5ef4fc3..600ae82 100644
--- a/src/brpc/policy/weighted_randomized_load_balancer.cpp
+++ b/src/brpc/policy/weighted_randomized_load_balancer.cpp
@@ -19,6 +19,7 @@
 #include <algorithm>
 
 #include "butil/fast_rand.h"
+#include "butil/logging.h"
 #include "brpc/socket.h"
 #include "brpc/policy/weighted_randomized_load_balancer.h"
 #include "butil/strings/string_number_conversions.h"
diff --git a/src/brpc/policy/weighted_round_robin_load_balancer.cpp b/src/brpc/policy/weighted_round_robin_load_balancer.cpp
index 1e6add5..9a4080f 100644
--- a/src/brpc/policy/weighted_round_robin_load_balancer.cpp
+++ b/src/brpc/policy/weighted_round_robin_load_balancer.cpp
@@ -19,6 +19,7 @@
 #include <algorithm>
 
 #include "butil/fast_rand.h"
+#include "butil/logging.h"
 #include "brpc/socket.h"
 #include "brpc/policy/weighted_round_robin_load_balancer.h"
 #include "butil/strings/string_number_conversions.h"
diff --git a/src/brpc/protocol.cpp b/src/brpc/protocol.cpp
index 3e2c717..85dee85 100644
--- a/src/brpc/protocol.cpp
+++ b/src/brpc/protocol.cpp
@@ -203,7 +203,7 @@ BUTIL_FORCE_INLINE bool ParsePbFromZeroCopyStreamInlined(
     // According to source code of pb, SetTotalBytesLimit is not a simple set,
     // avoid calling the function when the limit is definitely unreached.
     if (PB_TOTAL_BYETS_LIMITS < FLAGS_max_body_size) {
-        decoder.SetTotalBytesLimit(INT_MAX, -1);
+        decoder.SetTotalBytesLimit(INT_MAX);
     }
     return msg->ParseFromCodedStream(&decoder) && decoder.ConsumedEntireMessage();
 }
diff --git a/src/brpc/protocol.h b/src/brpc/protocol.h
index c1e0602..f8fcea7 100755
--- a/src/brpc/protocol.h
+++ b/src/brpc/protocol.h
@@ -27,7 +27,7 @@
 #include <gflags/gflags_declare.h>                 // DECLARE_xxx
 #include "butil/endpoint.h"                         // butil::EndPoint
 #include "butil/iobuf.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "brpc/options.pb.h"                  // ProtocolType
 #include "brpc/socket_id.h"                   // SocketId
 #include "brpc/parse_result.h"                // ParseResult
@@ -221,7 +221,7 @@ public:
         if (_size < N) {
             return _arr[_size++];
         } else {
-            CHECK(false) << "push to a full array, cap=" << N;
+            //CHECK(false) << "push to a full array, cap=" << N;
             static T dummy;
             return dummy;
         }
diff --git a/src/brpc/redis.cpp b/src/brpc/redis.cpp
index 50cab08..d90a355 100644
--- a/src/brpc/redis.cpp
+++ b/src/brpc/redis.cpp
@@ -19,6 +19,7 @@
 #include <google/protobuf/reflection_ops.h>     // ReflectionOps::Merge
 #include <gflags/gflags.h>
 #include "butil/status.h"
+#include "butil/logging.h"
 #include "butil/strings/string_util.h"          // StringToLowerASCII
 #include "brpc/redis.h"
 #include "brpc/redis_command.h"
diff --git a/src/brpc/redis.h b/src/brpc/redis.h
index d90da9e..0433c61 100644
--- a/src/brpc/redis.h
+++ b/src/brpc/redis.h
@@ -108,6 +108,13 @@ public:
 
     // Protobuf methods.
     RedisRequest* New() const;
+    RedisRequest* New(::google::protobuf::Arena* arena) const {
+        RedisRequest* message = New();
+        if (arena != nullptr) {
+            arena->Own(message);
+        }
+        return message;
+    }
     void CopyFrom(const ::google::protobuf::Message& from);
     void MergeFrom(const ::google::protobuf::Message& from);
     void CopyFrom(const RedisRequest& from);
@@ -178,6 +185,13 @@ public:
     // implements Message ----------------------------------------------
   
     RedisResponse* New() const;
+    RedisResponse* New(::google::protobuf::Arena* arena) const {
+        RedisResponse* message = New();
+        if (arena != nullptr) {
+            arena->Own(message);
+        }
+        return message;
+    }
     void CopyFrom(const ::google::protobuf::Message& from);
     void MergeFrom(const ::google::protobuf::Message& from);
     void CopyFrom(const RedisResponse& from);
diff --git a/src/brpc/redis_reply.h b/src/brpc/redis_reply.h
index d2515d8..a608bcc 100644
--- a/src/brpc/redis_reply.h
+++ b/src/brpc/redis_reply.h
@@ -22,7 +22,7 @@
 #include "butil/iobuf.h"                  // butil::IOBuf
 #include "butil/strings/string_piece.h"   // butil::StringPiece
 #include "butil/arena.h"                  // butil::Arena
-#include "butil/logging.h"                // CHECK
+//#include "butil/logging.h"                // CHECK
 #include "parse_result.h"                 // ParseError
 
 
@@ -197,8 +197,8 @@ inline int64_t RedisReply::integer() const {
     if (is_integer()) {
         return _data.integer;
     }
-    CHECK(false) << "The reply is " << RedisReplyTypeToString(_type)
-                 << ", not an integer";
+    //CHECK(false) << "The reply is " << RedisReplyTypeToString(_type)
+    //             << ", not an integer";
     return 0;
 }
 
@@ -265,8 +265,8 @@ inline const char* RedisReply::c_str() const {
             return _data.long_str;
         }
     }
-    CHECK(false) << "The reply is " << RedisReplyTypeToString(_type)
-                 << ", not a string";
+    //CHECK(false) << "The reply is " << RedisReplyTypeToString(_type)
+    //             << ", not a string";
     return "";
 }
 
@@ -278,8 +278,8 @@ inline butil::StringPiece RedisReply::data() const {
             return butil::StringPiece(_data.long_str, _length);
         }
     }
-    CHECK(false) << "The reply is " << RedisReplyTypeToString(_type)
-                 << ", not a string";
+    //CHECK(false) << "The reply is " << RedisReplyTypeToString(_type)
+    //             << ", not a string";
     return butil::StringPiece();
 }
 
@@ -291,8 +291,8 @@ inline const char* RedisReply::error_message() const {
             return _data.long_str;
         }
     }
-    CHECK(false) << "The reply is " << RedisReplyTypeToString(_type)
-                 << ", not an error";
+    //CHECK(false) << "The reply is " << RedisReplyTypeToString(_type)
+    //             << ", not an error";
     return "";
 }
 
diff --git a/src/brpc/restful.cpp b/src/brpc/restful.cpp
index 32554e8..9752731 100644
--- a/src/brpc/restful.cpp
+++ b/src/brpc/restful.cpp
@@ -17,6 +17,7 @@
 
 
 #include <google/protobuf/descriptor.h>
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/restful.h"
 #include "brpc/details/method_status.h"
diff --git a/src/brpc/rpc_dump.cpp b/src/brpc/rpc_dump.cpp
index bf3d7fc..625ffe1 100644
--- a/src/brpc/rpc_dump.cpp
+++ b/src/brpc/rpc_dump.cpp
@@ -28,6 +28,7 @@
 #include "brpc/reloadable_flags.h"
 #include "brpc/rpc_dump.h"
 #include "brpc/protocol.h"
+#include "butil/logging.h"
 
 namespace bvar {
 std::string read_command_name();
diff --git a/src/brpc/rtmp.cpp b/src/brpc/rtmp.cpp
index ae6eb6a..977313b 100644
--- a/src/brpc/rtmp.cpp
+++ b/src/brpc/rtmp.cpp
@@ -20,6 +20,7 @@
 #include <google/protobuf/io/zero_copy_stream_impl_lite.h> // StringOutputStream
 #include "bthread/bthread.h"                      // bthread_id_xx
 #include "bthread/unstable.h"                     // bthread_timer_del
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/callback.h"                   // Closure
 #include "brpc/channel.h"                    // Channel
diff --git a/src/brpc/selective_channel.cpp b/src/brpc/selective_channel.cpp
index 66a916b..fbcdcc4 100644
--- a/src/brpc/selective_channel.cpp
+++ b/src/brpc/selective_channel.cpp
@@ -24,7 +24,7 @@
 #include "brpc/details/controller_private_accessor.h"        // RPCSender
 #include "brpc/selective_channel.h"
 #include "brpc/global.h"
-
+#include "butil/logging.h"
 
 namespace brpc {
 
diff --git a/src/brpc/serialized_request.h b/src/brpc/serialized_request.h
index c59495d..d4dfda3 100644
--- a/src/brpc/serialized_request.h
+++ b/src/brpc/serialized_request.h
@@ -44,6 +44,13 @@ public:
     // implements Message ----------------------------------------------
   
     SerializedRequest* New() const;
+    SerializedRequest* New(::google::protobuf::Arena* arena) const {
+        SerializedRequest* message = New();
+        if (arena != nullptr) {
+            arena->Own(message);
+        }
+        return message;
+    }
     void CopyFrom(const ::google::protobuf::Message& from);
     void CopyFrom(const SerializedRequest& from);
     void Clear();
diff --git a/src/brpc/server_id.cpp b/src/brpc/server_id.cpp
index c3a595b..57314a0 100644
--- a/src/brpc/server_id.cpp
+++ b/src/brpc/server_id.cpp
@@ -17,7 +17,7 @@
 
 
 #include "brpc/server_id.h"
-
+#include "butil/logging.h"
 
 namespace brpc {
 
diff --git a/src/brpc/simple_data_pool.h b/src/brpc/simple_data_pool.h
index 390f6e5..51b2434 100644
--- a/src/brpc/simple_data_pool.h
+++ b/src/brpc/simple_data_pool.h
@@ -21,7 +21,7 @@
 
 #include "butil/scoped_lock.h"
 #include "brpc/data_factory.h"
-
+#include "butil/atomicops.h"
 
 namespace brpc {
 
diff --git a/src/brpc/socket_inl.h b/src/brpc/socket_inl.h
index 31ce6a9..c16a6a0 100644
--- a/src/brpc/socket_inl.h
+++ b/src/brpc/socket_inl.h
@@ -114,10 +114,10 @@ inline int Socket::Dereference() {
             }
             return 0;
         }
-        LOG(FATAL) << "Invalid SocketId=" << id;
+        //LOG(FATAL) << "Invalid SocketId=" << id;
         return -1;
     }
-    LOG(FATAL) << "Over dereferenced SocketId=" << id;
+    //LOG(FATAL) << "Over dereferenced SocketId=" << id;
     return -1;
 }
 
@@ -153,15 +153,15 @@ inline int Socket::Address(SocketId id, SocketUniquePtr* ptr) {
                         return_resource(SlotOfSocketId(id));
                     }
                 } else {
-                    CHECK(false) << "ref-version=" << ver1
-                                 << " unref-version=" << ver2;
+                    //CHECK(false) << "ref-version=" << ver1
+                    //             << " unref-version=" << ver2;
                 }
             } else {
-                CHECK_EQ(ver1, ver2);
+                //CHECK_EQ(ver1, ver2);
                 // Addressed a free slot.
             }
         } else {
-            CHECK(false) << "Over dereferenced SocketId=" << id;
+            //CHECK(false) << "Over dereferenced SocketId=" << id;
         }
     }
     return -1;
@@ -206,14 +206,14 @@ inline int Socket::AddressFailedAsWell(SocketId id, SocketUniquePtr* ptr) {
                         return_resource(slot);
                     }
                 } else {
-                    CHECK(false) << "ref-version=" << ver1
-                                 << " unref-version=" << ver2;
+                    //CHECK(false) << "ref-version=" << ver1
+                    //             << " unref-version=" << ver2;
                 }
             } else {
                 // Addressed a free slot.
             }
         } else {
-            CHECK(false) << "Over dereferenced SocketId=" << id;
+            //CHECK(false) << "Over dereferenced SocketId=" << id;
         }
     }
     return -1;    
diff --git a/src/brpc/stream.cpp b/src/brpc/stream.cpp
index e48441e..2e39437 100644
--- a/src/brpc/stream.cpp
+++ b/src/brpc/stream.cpp
@@ -22,6 +22,7 @@
 #include "butil/time.h"
 #include "butil/object_pool.h"
 #include "butil/unique_ptr.h"
+#include "butil/logging.h"
 #include "bthread/unstable.h"
 #include "brpc/log.h"
 #include "brpc/socket.h"
diff --git a/src/brpc/thrift_message.h b/src/brpc/thrift_message.h
index a152b16..3bea5cf 100644
--- a/src/brpc/thrift_message.h
+++ b/src/brpc/thrift_message.h
@@ -84,6 +84,13 @@ public:
     // implements Message ----------------------------------------------
   
     ThriftFramedMessage* New() const;
+    ThriftFramedMessage* New(::google::protobuf::Arena* arena) const {
+        ThriftFramedMessage* message = New();
+        if (arena != nullptr) {
+            arena->Own(message);
+        }
+        return message;
+    }
     void CopyFrom(const ::google::protobuf::Message& from);
     void MergeFrom(const ::google::protobuf::Message& from);
     void CopyFrom(const ThriftFramedMessage& from);
@@ -198,7 +205,7 @@ T* ThriftFramedMessage::Cast() {
 
     if (!body.empty()) {
         if (!policy::ReadThriftStruct(body, _raw_instance, field_id)) {
-            LOG(ERROR) << "Fail to parse " << butil::class_name<T>();
+            //LOG(ERROR) << "Fail to parse " << butil::class_name<T>();
         }
     }
     return raw_msg;
diff --git a/src/brpc/thrift_service.cpp b/src/brpc/thrift_service.cpp
index 283ea48..6523f7d 100644
--- a/src/brpc/thrift_service.cpp
+++ b/src/brpc/thrift_service.cpp
@@ -19,6 +19,7 @@
 #include "butil/class_name.h"
 #include "brpc/thrift_service.h"
 #include "brpc/details/method_status.h"
+#include "butil/logging.h"
 
 namespace brpc {
 
diff --git a/src/brpc/trackme.cpp b/src/brpc/trackme.cpp
index 85598a6..7ebc70a 100644
--- a/src/brpc/trackme.cpp
+++ b/src/brpc/trackme.cpp
@@ -24,6 +24,7 @@
 #include <sys/types.h>
 #include <pwd.h>
 #include "butil/fast_rand.h"
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/channel.h"
 #include "brpc/trackme.pb.h"
diff --git a/src/brpc/ts.cpp b/src/brpc/ts.cpp
index ebefe53..d08574e 100644
--- a/src/brpc/ts.cpp
+++ b/src/brpc/ts.cpp
@@ -34,6 +34,7 @@
 // IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 // CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
+#include "butil/logging.h"
 #include "brpc/log.h"
 #include "brpc/policy/rtmp_protocol.h"
 #include "brpc/ts.h"
diff --git a/src/brpc/uri.cpp b/src/brpc/uri.cpp
index f5d544c..8cc44c2 100644
--- a/src/brpc/uri.cpp
+++ b/src/brpc/uri.cpp
@@ -23,7 +23,7 @@
 #include "brpc/log.h"
 #include "brpc/details/http_parser.h"      // http_parser_parse_url
 #include "brpc/uri.h"                      // URI
-
+#include "butil/logging.h"
 
 namespace brpc {
 
diff --git a/src/bthread/countdown_event.cpp b/src/bthread/countdown_event.cpp
index 3d0d652..fb504cf 100644
--- a/src/bthread/countdown_event.cpp
+++ b/src/bthread/countdown_event.cpp
@@ -22,6 +22,7 @@
 #include "butil/atomicops.h"     // butil::atomic<int>
 #include "bthread/butex.h"
 #include "bthread/countdown_event.h"
+#include "butil/logging.h"
 
 namespace bthread {
 
diff --git a/src/bthread/execution_queue.cpp b/src/bthread/execution_queue.cpp
index 569698b..590e20f 100644
--- a/src/bthread/execution_queue.cpp
+++ b/src/bthread/execution_queue.cpp
@@ -24,6 +24,7 @@
 #include "butil/memory/singleton_on_pthread_once.h"
 #include "butil/object_pool.h"           // butil::get_object
 #include "butil/resource_pool.h"         // butil::get_resource
+#include "butil/logging.h"
 
 namespace bthread {
 
diff --git a/src/bthread/execution_queue_inl.h b/src/bthread/execution_queue_inl.h
index 7911db6..9ebefce 100644
--- a/src/bthread/execution_queue_inl.h
+++ b/src/bthread/execution_queue_inl.h
@@ -25,7 +25,7 @@
 #include "butil/atomicops.h"             // butil::atomic
 #include "butil/macros.h"                // BAIDU_CACHELINE_ALIGNMENT
 #include "butil/memory/scoped_ptr.h"     // butil::scoped_ptr
-#include "butil/logging.h"               // LOG
+//#include "butil/logging.h"               // LOG
 #include "butil/time.h"                  // butil::cpuwide_time_ns
 #include "bvar/bvar.h"                  // bvar::Adder
 #include "bthread/butex.h"              // butex_construct
@@ -99,18 +99,18 @@ struct BAIDU_CACHELINE_ALIGNMENT TaskNode {
     void clear_before_return(clear_task_mem clear_func) {
         if (!stop_task) {
             clear_func(this);
-            CHECK(iterated);
+            //CHECK(iterated);
         }
         q = NULL;
         std::unique_lock<butil::Mutex> lck(mutex);
         ++version;
-        const int saved_status = status;
+        //const int saved_status = status;
         status = UNEXECUTED;
         lck.unlock();
-        CHECK_NE(saved_status, UNEXECUTED);
-        LOG_IF(WARNING, saved_status == EXECUTING) 
-                << "Return a executing node, did you return before "
-                   "iterator reached the end?";
+        //CHECK_NE(saved_status, UNEXECUTED);
+        //LOG_IF(WARNING, saved_status == EXECUTING)
+        //        << "Return a executing node, did you return before "
+        //           "iterator reached the end?";
     }
 
     static TaskNode* const UNCONNECTED;
@@ -433,7 +433,7 @@ inline bool ExecutionQueueBase::_more_tasks(
         TaskNode* old_head, TaskNode** new_tail, 
         bool has_uniterated) {
 
-    CHECK(old_head->next == NULL);
+    //CHECK(old_head->next == NULL);
     // Try to set _head to NULL to mark that the execute is done.
     TaskNode* new_head = old_head;
     TaskNode* desired = NULL;
@@ -447,7 +447,7 @@ inline bool ExecutionQueueBase::_more_tasks(
         // No one added new tasks.
         return return_when_no_more;
     }
-    CHECK_NE(new_head, old_head);
+    //CHECK_NE(new_head, old_head);
     // Above acquire fence pairs release fence of exchange in Write() to make
     // sure that we see all fields of requests set.
 
@@ -467,7 +467,7 @@ inline bool ExecutionQueueBase::_more_tasks(
         p->next = tail;
         tail = p;
         p = saved_next;
-        CHECK(p != NULL);
+        //CHECK(p != NULL);
     } while (p != old_head);
 
     // Link old list with new list.
@@ -526,10 +526,10 @@ inline int ExecutionQueueBase::dereference() {
             }
             return 0;
         }
-        LOG(FATAL) << "Invalid id=" << id;
+        //LOG(FATAL) << "Invalid id=" << id;
         return -1;
     }
-    LOG(FATAL) << "Over dereferenced id=" << id;
+    //LOG(FATAL) << "Over dereferenced id=" << id;
     return -1;
 }
 
diff --git a/src/bthread/key.cpp b/src/bthread/key.cpp
index 53f7594..3a0e79f 100644
--- a/src/bthread/key.cpp
+++ b/src/bthread/key.cpp
@@ -25,6 +25,7 @@
 #include "bvar/passive_status.h"
 #include "bthread/errno.h"                       // EAGAIN
 #include "bthread/task_group.h"                  // TaskGroup
+#include "butil/logging.h"
 
 // Implement bthread_key_t related functions
 
diff --git a/src/bthread/mutex.h b/src/bthread/mutex.h
index 257f179..e749ea9 100644
--- a/src/bthread/mutex.h
+++ b/src/bthread/mutex.h
@@ -51,7 +51,7 @@ public:
             throw std::system_error(std::error_code(ec, std::system_category()), "Mutex constructor failed");
         }
     }
-    ~Mutex() { CHECK_EQ(0, bthread_mutex_destroy(&_mutex)); }
+    ~Mutex() { bthread_mutex_destroy(&_mutex); }
     native_handler_type native_handler() { return &_mutex; }
     void lock() {
         int ec = bthread_mutex_lock(&_mutex);
@@ -98,7 +98,7 @@ public:
 #if !defined(NDEBUG)
         const int rc = bthread_mutex_lock(_pmutex);
         if (rc) {
-            LOG(FATAL) << "Fail to lock bthread_mutex_t=" << _pmutex << ", " << berror(rc);
+            //LOG(FATAL) << "Fail to lock bthread_mutex_t=" << _pmutex << ", " << berror(rc);
             _pmutex = NULL;
         }
 #else
@@ -148,11 +148,11 @@ public:
 
     void lock() {
         if (!_mutex) {
-            CHECK(false) << "Invalid operation";
+            //CHECK(false) << "Invalid operation";
             return;
         }
         if (_owns_lock) {
-            CHECK(false) << "Detected deadlock issue";     
+            //CHECK(false) << "Detected deadlock issue";
             return;
         }
         bthread_mutex_lock(_mutex);
@@ -161,11 +161,11 @@ public:
 
     bool try_lock() {
         if (!_mutex) {
-            CHECK(false) << "Invalid operation";
+            //CHECK(false) << "Invalid operation";
             return false;
         }
         if (_owns_lock) {
-            CHECK(false) << "Detected deadlock issue";     
+            //CHECK(false) << "Detected deadlock issue";
             return false;
         }
         _owns_lock = !bthread_mutex_trylock(_mutex);
@@ -174,7 +174,7 @@ public:
 
     void unlock() {
         if (!_owns_lock) {
-            CHECK(false) << "Invalid operation";
+            //CHECK(false) << "Invalid operation";
             return;
         }
         if (_mutex) {
diff --git a/src/bthread/stack.cpp b/src/bthread/stack.cpp
index 43e57ef..2154fc0 100644
--- a/src/bthread/stack.cpp
+++ b/src/bthread/stack.cpp
@@ -30,6 +30,7 @@
 #include "bvar/passive_status.h"
 #include "bthread/types.h"                        // BTHREAD_STACKTYPE_*
 #include "bthread/stack.h"
+#include "butil/logging.h"
 
 DEFINE_int32(stack_size_small, 32768, "size of small stacks");
 DEFINE_int32(stack_size_normal, 1048576, "size of normal stacks");
diff --git a/src/bthread/task_group.cpp b/src/bthread/task_group.cpp
index 7c41653..b391f9a 100644
--- a/src/bthread/task_group.cpp
+++ b/src/bthread/task_group.cpp
@@ -36,6 +36,7 @@
 #include "bthread/task_group.h"
 #include "bthread/timer_thread.h"
 #include "bthread/errno.h"
+#include "butil/logging.h"
 
 namespace bthread {
 
diff --git a/src/bthread/task_group_inl.h b/src/bthread/task_group_inl.h
index d48ceaa..b329554 100644
--- a/src/bthread/task_group_inl.h
+++ b/src/bthread/task_group_inl.h
@@ -88,7 +88,7 @@ inline void TaskGroup::push_rq(bthread_t tid) {
         //   are busy at creating bthreads (proved by test_input_messenger in
         //   brpc)
         flush_nosignal_tasks();
-        LOG_EVERY_SECOND(ERROR) << "_rq is full, capacity=" << _rq.capacity();
+        //LOG_EVERY_SECOND(ERROR) << "_rq is full, capacity=" << _rq.capacity();
         // TODO(gejun): May cause deadlock when all workers are spinning here.
         // A better solution is to pop and run existing bthreads, however which
         // make set_remained()-callbacks do context switches and need extensive
diff --git a/src/bthread/types.h b/src/bthread/types.h
index 45bf4be..b394430 100644
--- a/src/bthread/types.h
+++ b/src/bthread/types.h
@@ -23,8 +23,9 @@
 #define BTHREAD_TYPES_H
 
 #include <stdint.h>                            // uint64_t
+#include <iostream>
 #if defined(__cplusplus)
-#include "butil/logging.h"                      // CHECK
+//#include "butil/logging.h"                      // CHECK
 #endif
 
 typedef uint64_t bthread_t;
@@ -100,7 +101,7 @@ typedef struct bthread_attr_t {
         keytable_pool = NULL;
     }
     bthread_attr_t operator|(unsigned other_flags) const {
-        CHECK(!(other_flags & 7)) << "flags=" << other_flags;
+        //CHECK(!(other_flags & 7)) << "flags=" << other_flags;
         bthread_attr_t tmp = *this;
         tmp.flags |= (other_flags & ~(unsigned)7u);
         return tmp;
diff --git a/src/bthread/work_stealing_queue.h b/src/bthread/work_stealing_queue.h
index 3750ac5..79932f6 100644
--- a/src/bthread/work_stealing_queue.h
+++ b/src/bthread/work_stealing_queue.h
@@ -24,7 +24,7 @@
 
 #include "butil/macros.h"
 #include "butil/atomicops.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 
 namespace bthread {
 
@@ -45,16 +45,16 @@ public:
 
     int init(size_t capacity) {
         if (_capacity != 0) {
-            LOG(ERROR) << "Already initialized";
+            //LOG(ERROR) << "Already initialized";
             return -1;
         }
         if (capacity == 0) {
-            LOG(ERROR) << "Invalid capacity=" << capacity;
+            //LOG(ERROR) << "Invalid capacity=" << capacity;
             return -1;
         }
         if (capacity & (capacity - 1)) {
-            LOG(ERROR) << "Invalid capacity=" << capacity
-                       << " which must be power of 2";
+            //LOG(ERROR) << "Invalid capacity=" << capacity
+            //           << " which must be power of 2";
             return -1;
         }
         _buffer = new(std::nothrow) T[capacity];
diff --git a/src/butil/bits.h b/src/butil/bits.h
index 530e479..b9a6f44 100644
--- a/src/butil/bits.h
+++ b/src/butil/bits.h
@@ -8,7 +8,7 @@
 #define BUTIL_BITS_H_
 
 #include "butil/basictypes.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 
 namespace butil {
 namespace bits {
@@ -27,7 +27,7 @@ inline int Log2Floor(uint32_t n) {
       log += shift;
     }
   }
-  DCHECK_EQ(value, 1u);
+  //DCHECK_EQ(value, 1u);
   return log;
 }
 
diff --git a/src/butil/cancelable_callback.h b/src/butil/cancelable_callback.h
index f2d0465..b4e1f76 100644
--- a/src/butil/cancelable_callback.h
+++ b/src/butil/cancelable_callback.h
@@ -47,7 +47,7 @@
 #include "butil/callback.h"
 #include "butil/callback_internal.h"
 #include "butil/compiler_specific.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "butil/memory/weak_ptr.h"
 
 namespace butil {
@@ -64,7 +64,7 @@ class CancelableCallback<void(void)> {
   explicit CancelableCallback(const butil::Callback<void(void)>& callback)
       : weak_factory_(this),
         callback_(callback) {
-    DCHECK(!callback.is_null());
+    //DCHECK(!callback.is_null());
     InitializeForwarder();
   }
 
@@ -85,7 +85,7 @@ class CancelableCallback<void(void)> {
   // Sets |callback| as the closure that may be cancelled. |callback| may not
   // be null. Outstanding and any previously wrapped callbacks are cancelled.
   void Reset(const butil::Callback<void(void)>& callback) {
-    DCHECK(!callback.is_null());
+    //DCHECK(!callback.is_null());
 
     // Outstanding tasks (e.g., posted to a message loop) must not be called.
     Cancel();
@@ -134,7 +134,7 @@ class CancelableCallback<void(A1)> {
   explicit CancelableCallback(const butil::Callback<void(A1)>& callback)
       : weak_factory_(this),
         callback_(callback) {
-    DCHECK(!callback.is_null());
+    //DCHECK(!callback.is_null());
     InitializeForwarder();
   }
 
@@ -155,7 +155,7 @@ class CancelableCallback<void(A1)> {
   // Sets |callback| as the closure that may be cancelled. |callback| may not
   // be null. Outstanding and any previously wrapped callbacks are cancelled.
   void Reset(const butil::Callback<void(A1)>& callback) {
-    DCHECK(!callback.is_null());
+    //DCHECK(!callback.is_null());
 
     // Outstanding tasks (e.g., posted to a message loop) must not be called.
     Cancel();
@@ -204,7 +204,7 @@ class CancelableCallback<void(A1, A2)> {
   explicit CancelableCallback(const butil::Callback<void(A1, A2)>& callback)
       : weak_factory_(this),
         callback_(callback) {
-    DCHECK(!callback.is_null());
+    //DCHECK(!callback.is_null());
     InitializeForwarder();
   }
 
@@ -225,7 +225,7 @@ class CancelableCallback<void(A1, A2)> {
   // Sets |callback| as the closure that may be cancelled. |callback| may not
   // be null. Outstanding and any previously wrapped callbacks are cancelled.
   void Reset(const butil::Callback<void(A1, A2)>& callback) {
-    DCHECK(!callback.is_null());
+    //DCHECK(!callback.is_null());
 
     // Outstanding tasks (e.g., posted to a message loop) must not be called.
     Cancel();
diff --git a/src/butil/containers/bounded_queue.h b/src/butil/containers/bounded_queue.h
index 55f06e1..842c04b 100644
--- a/src/butil/containers/bounded_queue.h
+++ b/src/butil/containers/bounded_queue.h
@@ -26,7 +26,7 @@
 #define BUTIL_BOUNDED_QUEUE_H
 
 #include "butil/macros.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 
 namespace butil {
 
@@ -64,7 +64,7 @@ public:
         , _start(0)
         , _ownership(ownership)
         , _items(mem) {
-        DCHECK(_items);
+        //DCHECK(_items);
     };
     
     // Construct a queue with the given capacity.
@@ -76,7 +76,7 @@ public:
         , _start(0)
         , _ownership(OWNS_STORAGE)
         , _items(malloc(capacity * sizeof(T))) {
-        DCHECK(_items);
+        //DCHECK(_items);
     };
     
     BoundedQueue()
diff --git a/src/butil/containers/doubly_buffered_data.h b/src/butil/containers/doubly_buffered_data.h
index 93ba342..9822dbb 100644
--- a/src/butil/containers/doubly_buffered_data.h
+++ b/src/butil/containers/doubly_buffered_data.h
@@ -24,7 +24,7 @@
 #include <pthread.h>
 #include "butil/scoped_lock.h"
 #include "butil/thread_local.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "butil/macros.h"
 #include "butil/type_traits.h"
 #include "butil/errno.h"
@@ -282,7 +282,7 @@ DoublyBufferedData<T, TLS>::DoublyBufferedData()
     const int rc = pthread_key_create(&_wrapper_key,
                                       butil::delete_object<Wrapper>);
     if (rc != 0) {
-        LOG(FATAL) << "Fail to pthread_key_create: " << berror(rc);
+        //LOG(FATAL) << "Fail to pthread_key_create: " << berror(rc);
     } else {
         _created_key = true;
     }
@@ -374,7 +374,7 @@ size_t DoublyBufferedData<T, TLS>::Modify(Fn& fn) {
     }
 
     const size_t ret2 = fn(_data[bg_index]);
-    CHECK_EQ(ret2, ret) << "index=" << _index.load(butil::memory_order_relaxed);
+    //CHECK_EQ(ret2, ret) << "index=" << _index.load(butil::memory_order_relaxed);
     return ret2;
 }
 
diff --git a/src/butil/containers/flat_map.h b/src/butil/containers/flat_map.h
index 27777e4..4556bf4 100644
--- a/src/butil/containers/flat_map.h
+++ b/src/butil/containers/flat_map.h
@@ -97,7 +97,7 @@
 #include <functional>
 #include <iostream>                               // std::ostream
 #include "butil/type_traits.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "butil/find_cstr.h"
 #include "butil/single_threaded_pool.h"            // SingleThreadedPool
 #include "butil/containers/hash_tables.h"          // hash<>
diff --git a/src/butil/containers/flat_map_inl.h b/src/butil/containers/flat_map_inl.h
index ef08d7b..573087f 100644
--- a/src/butil/containers/flat_map_inl.h
+++ b/src/butil/containers/flat_map_inl.h
@@ -277,14 +277,14 @@ FlatMap<_K, _T, _H, _E, _S>::operator=(const FlatMap<_K, _T, _H, _E, _S>& rhs) {
         // note: need an extra bucket to let iterator know where buckets end
         _buckets = (Bucket*)malloc(sizeof(Bucket) * (_nbucket + 1/*note*/));
         if (NULL == _buckets) {
-            LOG(ERROR) << "Fail to new _buckets";
+            //LOG(ERROR) << "Fail to new _buckets";
             return;
         }
         if (_S) {
             free(_thumbnail);
             _thumbnail = bit_array_malloc(_nbucket);
             if (NULL == _thumbnail) {
-                LOG(ERROR) << "Fail to new _thumbnail";
+                //LOG(ERROR) << "Fail to new _thumbnail";
                 return;
             }
             bit_array_clear(_thumbnail, _nbucket);
@@ -323,11 +323,11 @@ FlatMap<_K, _T, _H, _E, _S>::operator=(const FlatMap<_K, _T, _H, _E, _S>& rhs) {
 template <typename _K, typename _T, typename _H, typename _E, bool _S>
 int FlatMap<_K, _T, _H, _E, _S>::init(size_t nbucket, u_int load_factor) {
     if (initialized()) {
-        LOG(ERROR) << "Already initialized";
+        //LOG(ERROR) << "Already initialized";
         return -1;
     }
     if (load_factor < 10 || load_factor > 100) {
-        LOG(ERROR) << "Invalid load_factor=" << load_factor;
+        //LOG(ERROR) << "Invalid load_factor=" << load_factor;
         return -1;
     }
     _size = 0;
@@ -336,7 +336,7 @@ int FlatMap<_K, _T, _H, _E, _S>::init(size_t nbucket, u_int load_factor) {
                                 
     _buckets = (Bucket*)malloc(sizeof(Bucket) * (_nbucket + 1));
     if (NULL == _buckets) {
-        LOG(ERROR) << "Fail to new _buckets";
+        //LOG(ERROR) << "Fail to new _buckets";
         return -1;
     }
     for (size_t i = 0; i < _nbucket; ++i) {
@@ -347,7 +347,7 @@ int FlatMap<_K, _T, _H, _E, _S>::init(size_t nbucket, u_int load_factor) {
     if (_S) {
         _thumbnail = bit_array_malloc(_nbucket);
         if (NULL == _thumbnail) {
-            LOG(ERROR) << "Fail to new _thumbnail";
+            //LOG(ERROR) << "Fail to new _thumbnail";
             return -1;
         }
         bit_array_clear(_thumbnail, _nbucket);
@@ -600,7 +600,7 @@ bool FlatMap<_K, _T, _H, _E, _S>::resize(size_t nbucket2) {
 
     FlatMap new_map;
     if (new_map.init(nbucket2, _load_factor) != 0) {
-        LOG(ERROR) << "Fail to init new_map, nbucket=" << nbucket2;
+        //LOG(ERROR) << "Fail to init new_map, nbucket=" << nbucket2;
         return false;
     }
     for (iterator it = begin(); it != end(); ++it) {
diff --git a/src/butil/containers/mru_cache.h b/src/butil/containers/mru_cache.h
index e2bbef7..3102a56 100644
--- a/src/butil/containers/mru_cache.h
+++ b/src/butil/containers/mru_cache.h
@@ -22,7 +22,7 @@
 
 #include "butil/basictypes.h"
 #include "butil/containers/hash_tables.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 
 namespace butil {
 
@@ -174,7 +174,7 @@ class MRUCacheBase {
   size_type size() const {
     // We don't use ordering_.size() for the return value because
     // (as a linked list) it can be O(n).
-    DCHECK(index_.size() == ordering_.size());
+    //DCHECK(index_.size() == ordering_.size());
     return index_.size();
   }
 
diff --git a/src/butil/containers/scoped_ptr_hash_map.h b/src/butil/containers/scoped_ptr_hash_map.h
index a24e872..bcada67 100644
--- a/src/butil/containers/scoped_ptr_hash_map.h
+++ b/src/butil/containers/scoped_ptr_hash_map.h
@@ -10,7 +10,7 @@
 
 #include "butil/basictypes.h"
 #include "butil/containers/hash_tables.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "butil/memory/scoped_ptr.h"
 #include "butil/stl_util.h"
 
@@ -73,7 +73,7 @@ class ScopedPtrHashMap {
   }
 
   scoped_ptr<Value> take(iterator it) {
-    DCHECK(it != data_.end());
+    //DCHECK(it != data_.end());
     if (it == data_.end())
       return scoped_ptr<Value>();
 
@@ -91,7 +91,7 @@ class ScopedPtrHashMap {
   }
 
   scoped_ptr<Value> take_and_erase(iterator it) {
-    DCHECK(it != data_.end());
+    //DCHECK(it != data_.end());
     if (it == data_.end())
       return scoped_ptr<Value>();
 
diff --git a/src/butil/containers/small_map.h b/src/butil/containers/small_map.h
index 4b619a1..2d13982 100644
--- a/src/butil/containers/small_map.h
+++ b/src/butil/containers/small_map.h
@@ -11,7 +11,7 @@
 
 #include "butil/basictypes.h"
 #include "butil/containers/hash_tables.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "butil/memory/manual_constructor.h"
 
 namespace butil {
@@ -558,11 +558,11 @@ class SmallMap {
   }
 
   inline NormalMap* map() {
-    CHECK(UsingFullMap());
+    //CHECK(UsingFullMap());
     return map_.get();
   }
   inline const NormalMap* map() const {
-    CHECK(UsingFullMap());
+    //CHECK(UsingFullMap());
     return map_.get();
   }
 
diff --git a/src/butil/debug/leak_tracker.h b/src/butil/debug/leak_tracker.h
index 5f584d3..f0a4d6f 100644
--- a/src/butil/debug/leak_tracker.h
+++ b/src/butil/debug/leak_tracker.h
@@ -15,7 +15,7 @@
 #ifdef ENABLE_LEAK_TRACKER
 #include "butil/containers/linked_list.h"
 #include "butil/debug/stack_trace.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #endif  // ENABLE_LEAK_TRACKER
 
 // LeakTracker is a helper to verify that all instances of a class
@@ -93,13 +93,13 @@ class LeakTracker : public LinkNode<LeakTracker<T> > {
         stacktraces[count] = allocation_stack;
 
       ++count;
-      std::ostringstream err;
-      err << "Leaked " << node << " which was allocated by:";
-      allocation_stack.OutputToStream(&err);
-      LOG(ERROR) << err.str();
+      //std::ostringstream err;
+      //err << "Leaked " << node << " which was allocated by:";
+      //allocation_stack.OutputToStream(&err);
+      //LOG(ERROR) << err.str();
     }
 
-    CHECK_EQ(0u, count);
+    //CHECK_EQ(0u, count);
 
     // Hack to keep |stacktraces| and |count| alive (so compiler
     // doesn't optimize it out, and it will appear in mini-dumps).
diff --git a/src/butil/debug/proc_maps_linux.cc b/src/butil/debug/proc_maps_linux.cc
index 4d4888c..7ae694d 100644
--- a/src/butil/debug/proc_maps_linux.cc
+++ b/src/butil/debug/proc_maps_linux.cc
@@ -13,6 +13,7 @@
 #include "butil/file_util.h"
 #include "butil/files/scoped_file.h"
 #include "butil/strings/string_split.h"
+#include "butil/logging.h"
 
 #if defined(OS_ANDROID) && !defined(__LP64__)
 // In 32-bit mode, Bionic's inttypes.h defines PRI/SCNxPTR as an
diff --git a/src/butil/file_util.h b/src/butil/file_util.h
index 4eb164b..765f78a 100644
--- a/src/butil/file_util.h
+++ b/src/butil/file_util.h
@@ -32,7 +32,7 @@
 
 #if defined(OS_POSIX)
 #include "butil/file_descriptor_posix.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "butil/posix/eintr_wrapper.h"
 #endif
 
diff --git a/src/butil/files/dir_reader_linux.h b/src/butil/files/dir_reader_linux.h
index c701546..ffbebd6 100644
--- a/src/butil/files/dir_reader_linux.h
+++ b/src/butil/files/dir_reader_linux.h
@@ -11,7 +11,7 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "butil/posix/eintr_wrapper.h"
 
 // See the comments in dir_reader_posix.h about this.
@@ -37,8 +37,8 @@ class DirReaderLinux {
 
   ~DirReaderLinux() {
     if (fd_ >= 0) {
-      if (IGNORE_EINTR(close(fd_)))
-        RAW_LOG(ERROR, "Failed to close directory handle");
+      IGNORE_EINTR(close(fd_));
+      //  RAW_LOG(ERROR, "Failed to close directory handle");
     }
   }
 
@@ -60,7 +60,7 @@ class DirReaderLinux {
     if (r == 0)
       return false;
     if (r == -1) {
-      DPLOG(FATAL) << "getdents64 returned an error: " << errno;
+      //DPLOG(FATAL) << "getdents64 returned an error: " << errno;
       return false;
     }
     size_ = r;
diff --git a/src/butil/files/dir_reader_unix.h b/src/butil/files/dir_reader_unix.h
index 7e3c1e9..c4cbc24 100644
--- a/src/butil/files/dir_reader_unix.h
+++ b/src/butil/files/dir_reader_unix.h
@@ -26,7 +26,7 @@
 #include <unistd.h>
 #include <dirent.h>
 
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "butil/posix/eintr_wrapper.h"
 
 // See the comments in dir_reader_posix.h about this.
@@ -43,8 +43,8 @@ class DirReaderUnix {
 
   ~DirReaderUnix() {
     if (fd_ >= 0) {
-      if (IGNORE_EINTR(close(fd_)))
-        RAW_LOG(ERROR, "Failed to close directory handle");
+      IGNORE_EINTR(close(fd_));
+      //  RAW_LOG(ERROR, "Failed to close directory handle");
     }
     if(NULL != dir_){
         closedir(dir_);
diff --git a/src/butil/files/file.cc b/src/butil/files/file.cc
index b3ce118..9134347 100644
--- a/src/butil/files/file.cc
+++ b/src/butil/files/file.cc
@@ -37,7 +37,7 @@ File::File(PlatformFile platform_file)
       created_(false),
       async_(false) {
 #if defined(OS_POSIX)
-  DCHECK_GE(platform_file, -1);
+  //DCHECK_GE(platform_file, -1);
 #endif
 }
 
@@ -120,7 +120,7 @@ std::string File::ErrorToString(Error error) {
       break;
   }
 
-  NOTREACHED();
+  //NOTREACHED();
   return "";
 }
 
diff --git a/src/butil/files/scoped_file.h b/src/butil/files/scoped_file.h
index 4d4d6ea..4063655 100644
--- a/src/butil/files/scoped_file.h
+++ b/src/butil/files/scoped_file.h
@@ -8,7 +8,7 @@
 #include <stdio.h>
 
 #include "butil/base_export.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "butil/memory/scoped_ptr.h"
 #include "butil/scoped_generic.h"
 #include "butil/build_config.h"
diff --git a/src/butil/hash.h b/src/butil/hash.h
index 69468a9..b838ad7 100644
--- a/src/butil/hash.h
+++ b/src/butil/hash.h
@@ -10,7 +10,7 @@
 
 #include "butil/base_export.h"
 #include "butil/basictypes.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 
 namespace butil {
 
@@ -21,7 +21,7 @@ BUTIL_EXPORT uint32_t SuperFastHash(const char* data, int len);
 // WARNING: This hash function should not be used for any cryptographic purpose.
 inline uint32_t Hash(const char* data, size_t length) {
   if (length > static_cast<size_t>(std::numeric_limits<int>::max())) {
-    NOTREACHED();
+    //NOTREACHED();
     return 0;
   }
   return SuperFastHash(data, static_cast<int>(length));
diff --git a/src/butil/lazy_instance.h b/src/butil/lazy_instance.h
index 38b48a8..954c7af 100644
--- a/src/butil/lazy_instance.h
+++ b/src/butil/lazy_instance.h
@@ -41,7 +41,7 @@
 #include "butil/base_export.h"
 #include "butil/basictypes.h"
 #include "butil/debug/leak_annotations.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "butil/memory/aligned_memory.h"
 #include "butil/third_party/dynamic_annotations/dynamic_annotations.h"
 #include "butil/threading/thread_restrictions.h"
@@ -62,10 +62,10 @@ struct DefaultLazyInstanceTraits {
 #endif
 
   static Type* New(void* instance) {
-    DCHECK_EQ(reinterpret_cast<uintptr_t>(instance) & (ALIGNOF(Type) - 1), 0u)
-        << ": Bad boy, the buffer passed to placement new is not aligned!\n"
-        "This may break some stuff like SSE-based optimizations assuming the "
-        "<Type> objects are word aligned.";
+    // DCHECK_EQ(reinterpret_cast<uintptr_t>(instance) & (ALIGNOF(Type) - 1), 0u)
+    //    << ": Bad boy, the buffer passed to placement new is not aligned!\n"
+    //    "This may break some stuff like SSE-based optimizations assuming the "
+    //    "<Type> objects are word aligned.";
     // Use placement new to initialize our instance in our preallocated space.
     // The parenthesis is very important here to force POD type initialization.
     return new (instance) Type();
diff --git a/src/butil/memory/linked_ptr.h b/src/butil/memory/linked_ptr.h
index 5773b17..b8a7764 100644
--- a/src/butil/memory/linked_ptr.h
+++ b/src/butil/memory/linked_ptr.h
@@ -37,7 +37,7 @@
 #ifndef BUTIL_MEMORY_LINKED_PTR_H_
 #define BUTIL_MEMORY_LINKED_PTR_H_
 
-#include "butil/logging.h"  // for CHECK macros
+//#include "butil/logging.h"  // for CHECK macros
 
 // This is used internally by all instances of linked_ptr<>.  It needs to be
 // a non-template class because different types of linked_ptr<> can refer to
@@ -87,7 +87,7 @@ class linked_ptr {
   template <typename U> linked_ptr(linked_ptr<U> const& ptr) { copy(&ptr); }
 
   linked_ptr(linked_ptr const& ptr) {
-    DCHECK_NE(&ptr, this);
+    //DCHECK_NE(&ptr, this);
     copy(&ptr);
   }
 
@@ -118,7 +118,7 @@ class linked_ptr {
   // Sole ownership by this linked_ptr object is required.
   T* release() {
     bool last = link_.depart();
-    CHECK(last);
+    //CHECK(last);
     T* v = value_;
     value_ = NULL;
     return v;
diff --git a/src/butil/memory/ref_counted.h b/src/butil/memory/ref_counted.h
index 82704d8..12aa98a 100644
--- a/src/butil/memory/ref_counted.h
+++ b/src/butil/memory/ref_counted.h
@@ -11,7 +11,7 @@
 #include "butil/base_export.h"
 #include "butil/compiler_specific.h"
 #ifndef NDEBUG
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #endif
 #include "butil/threading/thread_collision_warner.h"
 
@@ -32,7 +32,7 @@ class BUTIL_EXPORT RefCountedBase {
 
   ~RefCountedBase() {
   #ifndef NDEBUG
-    DCHECK(in_dtor_) << "RefCounted object deleted without calling Release()";
+    //DCHECK(in_dtor_) << "RefCounted object deleted without calling Release()";
   #endif
   }
 
@@ -43,7 +43,7 @@ class BUTIL_EXPORT RefCountedBase {
     // without release it.
     // DFAKE_SCOPED_LOCK_THREAD_LOCKED(add_release_);
   #ifndef NDEBUG
-    DCHECK(!in_dtor_);
+    //DCHECK(!in_dtor_);
   #endif
     ++ref_count_;
   }
@@ -55,7 +55,7 @@ class BUTIL_EXPORT RefCountedBase {
     // without release it.
     // DFAKE_SCOPED_LOCK_THREAD_LOCKED(add_release_);
   #ifndef NDEBUG
-    DCHECK(!in_dtor_);
+    //DCHECK(!in_dtor_);
   #endif
     if (--ref_count_ == 0) {
   #ifndef NDEBUG
diff --git a/src/butil/memory/scoped_vector.h b/src/butil/memory/scoped_vector.h
index a2aeba7..34dc23c 100644
--- a/src/butil/memory/scoped_vector.h
+++ b/src/butil/memory/scoped_vector.h
@@ -8,7 +8,7 @@
 #include <vector>
 
 #include "butil/basictypes.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "butil/move.h"
 #include "butil/stl_util.h"
 
@@ -71,7 +71,7 @@ class ScopedVector {
   void push_back(T* elem) { v_.push_back(elem); }
 
   void pop_back() {
-    DCHECK(!empty());
+    //DCHECK(!empty());
     delete v_.back();
     v_.pop_back();
   }
diff --git a/src/butil/memory/weak_ptr.h b/src/butil/memory/weak_ptr.h
index fd65bc9..c5b2057 100644
--- a/src/butil/memory/weak_ptr.h
+++ b/src/butil/memory/weak_ptr.h
@@ -65,7 +65,7 @@
 
 #include "butil/basictypes.h"
 #include "butil/base_export.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "butil/memory/ref_counted.h"
 #include "butil/type_traits.h"
 
@@ -201,11 +201,11 @@ class WeakPtr : public internal::WeakPtrBase {
   T* get() const { return ref_.is_valid() ? ptr_ : NULL; }
 
   T& operator*() const {
-    DCHECK(get() != NULL);
+    //DCHECK(get() != NULL);
     return *get();
   }
   T* operator->() const {
-    DCHECK(get() != NULL);
+    //DCHECK(get() != NULL);
     return get();
   }
 
@@ -264,19 +264,19 @@ class WeakPtrFactory {
   }
 
   WeakPtr<T> GetWeakPtr() {
-    DCHECK(ptr_);
+    //DCHECK(ptr_);
     return WeakPtr<T>(weak_reference_owner_.GetRef(), ptr_);
   }
 
   // Call this method to invalidate all existing weak pointers.
   void InvalidateWeakPtrs() {
-    DCHECK(ptr_);
+    //DCHECK(ptr_);
     weak_reference_owner_.Invalidate();
   }
 
   // Call this method to determine if any weak pointers exist.
   bool HasWeakPtrs() const {
-    DCHECK(ptr_);
+    //DCHECK(ptr_);
     return weak_reference_owner_.HasRefs();
   }
 
diff --git a/src/butil/numerics/safe_conversions.h b/src/butil/numerics/safe_conversions.h
index 677aa4a..48344d6 100644
--- a/src/butil/numerics/safe_conversions.h
+++ b/src/butil/numerics/safe_conversions.h
@@ -7,7 +7,7 @@
 
 #include <limits>
 
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "butil/numerics/safe_conversions_impl.h"
 
 namespace butil {
@@ -25,7 +25,7 @@ inline bool IsValueInRangeForNumericType(Src value) {
 // overflow or underflow. NaN source will always trigger a CHECK.
 template <typename Dst, typename Src>
 inline Dst checked_cast(Src value) {
-  CHECK(IsValueInRangeForNumericType<Dst>(value));
+  //CHECK(IsValueInRangeForNumericType<Dst>(value));
   return static_cast<Dst>(value);
 }
 
@@ -50,7 +50,7 @@ inline Dst saturated_cast(Src value) {
 
     // Should fail only on attempting to assign NaN to a saturated integer.
     case internal::RANGE_INVALID:
-      CHECK(false);
+      //CHECK(false);
       return std::numeric_limits<Dst>::max();
   }
 
diff --git a/src/butil/observer_list.h b/src/butil/observer_list.h
index 8f0dd3b..b649efb 100644
--- a/src/butil/observer_list.h
+++ b/src/butil/observer_list.h
@@ -10,7 +10,7 @@
 #include <vector>
 
 #include "butil/basictypes.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "butil/memory/weak_ptr.h"
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -194,7 +194,7 @@ class ObserverList : public ObserverListBase<ObserverType> {
     // When check_empty is true, assert that the list is empty on destruction.
     if (check_empty) {
       ObserverListBase<ObserverType>::Compact();
-      DCHECK_EQ(ObserverListBase<ObserverType>::size(), 0U);
+      //DCHECK_EQ(ObserverListBase<ObserverType>::size(), 0U);
     }
   }
 
diff --git a/src/butil/scoped_lock.h b/src/butil/scoped_lock.h
index 45f5230..53d5c6b 100644
--- a/src/butil/scoped_lock.h
+++ b/src/butil/scoped_lock.h
@@ -26,7 +26,7 @@
 
 #include "butil/synchronization/lock.h"
 #include "butil/macros.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 #include "butil/errno.h"
 
 #if !defined(BUTIL_CXX11_ENABLED)
@@ -100,7 +100,7 @@ public:
 
     void lock() {
         if (_owns_lock) {
-            CHECK(false) << "Detected deadlock issue";     
+            //CHECK(false) << "Detected deadlock issue";
             return;
         }
         _owns_lock = true;
@@ -109,7 +109,7 @@ public:
 
     bool try_lock() {
         if (_owns_lock) {
-            CHECK(false) << "Detected deadlock issue";     
+            //CHECK(false) << "Detected deadlock issue";
             return false;
         }
         _owns_lock = _mutex->try_lock();
@@ -118,7 +118,7 @@ public:
 
     void unlock() {
         if (!_owns_lock) {
-            CHECK(false) << "Invalid operation";
+            //CHECK(false) << "Invalid operation";
             return;
         }
         _mutex->unlock();
@@ -156,7 +156,7 @@ public:
 #if !defined(NDEBUG)
         const int rc = pthread_mutex_lock(_pmutex);
         if (rc) {
-            LOG(FATAL) << "Fail to lock pthread_mutex_t=" << _pmutex << ", " << berror(rc);
+            //LOG(FATAL) << "Fail to lock pthread_mutex_t=" << _pmutex << ", " << berror(rc);
             _pmutex = NULL;
         }
 #else
@@ -185,7 +185,7 @@ public:
 #if !defined(NDEBUG)
         const int rc = pthread_spin_lock(_pspin);
         if (rc) {
-            LOG(FATAL) << "Fail to lock pthread_spinlock_t=" << _pspin << ", " << berror(rc);
+            //LOG(FATAL) << "Fail to lock pthread_spinlock_t=" << _pspin << ", " << berror(rc);
             _pspin = NULL;
         }
 #else
@@ -235,13 +235,13 @@ public:
 
     void lock() {
         if (_owns_lock) {
-            CHECK(false) << "Detected deadlock issue";     
+            //CHECK(false) << "Detected deadlock issue";
             return;
         }
 #if !defined(NDEBUG)
         const int rc = pthread_mutex_lock(_mutex);
         if (rc) {
-            LOG(FATAL) << "Fail to lock pthread_mutex=" << _mutex << ", " << berror(rc);
+            //LOG(FATAL) << "Fail to lock pthread_mutex=" << _mutex << ", " << berror(rc);
             return;
         }
         _owns_lock = true;
@@ -253,7 +253,7 @@ public:
 
     bool try_lock() {
         if (_owns_lock) {
-            CHECK(false) << "Detected deadlock issue";     
+            //CHECK(false) << "Detected deadlock issue";
             return false;
         }
         _owns_lock = !pthread_mutex_trylock(_mutex);
@@ -262,7 +262,7 @@ public:
 
     void unlock() {
         if (!_owns_lock) {
-            CHECK(false) << "Invalid operation";
+            //CHECK(false) << "Invalid operation";
             return;
         }
         pthread_mutex_unlock(_mutex);
@@ -317,13 +317,13 @@ public:
 
     void lock() {
         if (_owns_lock) {
-            CHECK(false) << "Detected deadlock issue";     
+            //CHECK(false) << "Detected deadlock issue";
             return;
         }
 #if !defined(NDEBUG)
         const int rc = pthread_spin_lock(_mutex);
         if (rc) {
-            LOG(FATAL) << "Fail to lock pthread_spinlock=" << _mutex << ", " << berror(rc);
+            //LOG(FATAL) << "Fail to lock pthread_spinlock=" << _mutex << ", " << berror(rc);
             return;
         }
         _owns_lock = true;
@@ -335,7 +335,7 @@ public:
 
     bool try_lock() {
         if (_owns_lock) {
-            CHECK(false) << "Detected deadlock issue";     
+            //CHECK(false) << "Detected deadlock issue";
             return false;
         }
         _owns_lock = !pthread_spin_trylock(_mutex);
@@ -344,7 +344,7 @@ public:
 
     void unlock() {
         if (!_owns_lock) {
-            CHECK(false) << "Invalid operation";
+            //CHECK(false) << "Invalid operation";
             return;
         }
         pthread_spin_unlock(_mutex);
@@ -381,11 +381,11 @@ namespace butil {
 // Lock both lck1 and lck2 without the dead lock issue
 template <typename Mutex1, typename Mutex2>
 void double_lock(std::unique_lock<Mutex1> &lck1, std::unique_lock<Mutex2> &lck2) {
-    DCHECK(!lck1.owns_lock());
-    DCHECK(!lck2.owns_lock());
+    //DCHECK(!lck1.owns_lock());
+    //DCHECK(!lck2.owns_lock());
     volatile void* const ptr1 = lck1.mutex();
     volatile void* const ptr2 = lck2.mutex();
-    DCHECK_NE(ptr1, ptr2);
+    //DCHECK_NE(ptr1, ptr2);
     if (ptr1 < ptr2) {
         lck1.lock();
         lck2.lock();
diff --git a/src/butil/stl_util.h b/src/butil/stl_util.h
index 19b638f..fa3e29f 100644
--- a/src/butil/stl_util.h
+++ b/src/butil/stl_util.h
@@ -13,7 +13,7 @@
 #include <string>
 #include <vector>
 
-#include "butil/logging.h"
+//#include "butil/logging.h"
 
 namespace butil {
 
@@ -211,8 +211,8 @@ bool STLIsSorted(const Container& cont) {
 // Returns a new ResultType containing the difference of two sorted containers.
 template <typename ResultType, typename Arg1, typename Arg2>
 ResultType STLSetDifference(const Arg1& a1, const Arg2& a2) {
-  DCHECK(STLIsSorted(a1));
-  DCHECK(STLIsSorted(a2));
+  //DCHECK(STLIsSorted(a1));
+  //DCHECK(STLIsSorted(a2));
   ResultType difference;
   std::set_difference(a1.begin(), a1.end(),
                       a2.begin(), a2.end(),
@@ -223,8 +223,8 @@ ResultType STLSetDifference(const Arg1& a1, const Arg2& a2) {
 // Returns a new ResultType containing the union of two sorted containers.
 template <typename ResultType, typename Arg1, typename Arg2>
 ResultType STLSetUnion(const Arg1& a1, const Arg2& a2) {
-  DCHECK(STLIsSorted(a1));
-  DCHECK(STLIsSorted(a2));
+  //DCHECK(STLIsSorted(a1));
+  //DCHECK(STLIsSorted(a2));
   ResultType result;
   std::set_union(a1.begin(), a1.end(),
                  a2.begin(), a2.end(),
@@ -236,8 +236,8 @@ ResultType STLSetUnion(const Arg1& a1, const Arg2& a2) {
 // containers.
 template <typename ResultType, typename Arg1, typename Arg2>
 ResultType STLSetIntersection(const Arg1& a1, const Arg2& a2) {
-  DCHECK(STLIsSorted(a1));
-  DCHECK(STLIsSorted(a2));
+  //DCHECK(STLIsSorted(a1));
+  //DCHECK(STLIsSorted(a2));
   ResultType result;
   std::set_intersection(a1.begin(), a1.end(),
                         a2.begin(), a2.end(),
@@ -249,8 +249,8 @@ ResultType STLSetIntersection(const Arg1& a1, const Arg2& a2) {
 // container |a2|.
 template <typename Arg1, typename Arg2>
 bool STLIncludes(const Arg1& a1, const Arg2& a2) {
-  DCHECK(STLIsSorted(a1));
-  DCHECK(STLIsSorted(a2));
+  //DCHECK(STLIsSorted(a1));
+  //DCHECK(STLIsSorted(a2));
   return std::includes(a1.begin(), a1.end(),
                        a2.begin(), a2.end());
 }
diff --git a/src/butil/strings/string_util.h b/src/butil/strings/string_util.h
index 23bc01e..e38b6e8 100644
--- a/src/butil/strings/string_util.h
+++ b/src/butil/strings/string_util.h
@@ -362,7 +362,7 @@ inline bool IsHexDigit(Char c) {
 
 template <typename Char>
 inline Char HexDigitToInt(Char c) {
-  DCHECK(IsHexDigit(c));
+  //DCHECK(IsHexDigit(c));
   if (c >= '0' && c <= '9')
     return c - '0';
   if (c >= 'A' && c <= 'F')
@@ -435,7 +435,7 @@ BUTIL_EXPORT void ReplaceSubstringsAfterOffset(std::string* str,
 template <class string_type>
 inline typename string_type::value_type* WriteInto(string_type* str,
                                                    size_t length_with_null) {
-  DCHECK_GT(length_with_null, 1u);
+  //DCHECK_GT(length_with_null, 1u);
   str->reserve(length_with_null);
   str->resize(length_with_null - 1);
   return &((*str)[0]);
diff --git a/src/butil/strings/string_util_posix.h b/src/butil/strings/string_util_posix.h
index 3496014..73add4e 100644
--- a/src/butil/strings/string_util_posix.h
+++ b/src/butil/strings/string_util_posix.h
@@ -10,7 +10,7 @@
 #include <string.h>
 #include <wchar.h>
 
-#include "butil/logging.h"
+//#include "butil/logging.h"
 
 namespace butil {
 
@@ -43,7 +43,7 @@ inline int strncmp16(const char16* s1, const char16* s2, size_t count) {
 
 inline int vswprintf(wchar_t* buffer, size_t size,
                      const wchar_t* format, va_list arguments) {
-  DCHECK(IsWprintfFormatPortable(format));
+  //DCHECK(IsWprintfFormatPortable(format));
   return ::vswprintf(buffer, size, format, arguments);
 }
 
diff --git a/src/butil/strings/stringprintf.cc b/src/butil/strings/stringprintf.cc
index 3f40e72..46efd74 100644
--- a/src/butil/strings/stringprintf.cc
+++ b/src/butil/strings/stringprintf.cc
@@ -9,6 +9,7 @@
 #include "butil/scoped_clear_errno.h"
 #include "butil/strings/string_util.h"
 #include "butil/strings/utf_string_conversions.h"
+#include "butil/logging.h"
 
 // gcc7 reports that the first arg to vsnprintfT in StringAppendVT is NULL,
 // which I can't figure out why, turn off the warning right now.
diff --git a/src/butil/strings/utf_string_conversions.cc b/src/butil/strings/utf_string_conversions.cc
index 065fbe3..0c9d735 100644
--- a/src/butil/strings/utf_string_conversions.cc
+++ b/src/butil/strings/utf_string_conversions.cc
@@ -7,6 +7,7 @@
 #include "butil/strings/string_piece.h"
 #include "butil/strings/string_util.h"
 #include "butil/strings/utf_string_conversion_utils.h"
+#include "butil/logging.h"
 
 namespace butil {
 
diff --git a/src/butil/synchronous_event.h b/src/butil/synchronous_event.h
index b0839e5..c142ace 100644
--- a/src/butil/synchronous_event.h
+++ b/src/butil/synchronous_event.h
@@ -23,7 +23,7 @@
 #include <vector>                             // std::vector
 #include <algorithm>                          // std::find
 #include <errno.h>                            // errno
-#include "butil/logging.h"
+//#include "butil/logging.h"
 
 // Synchronous event notification.
 // Observers to an event will be called immediately in the same context where
@@ -69,7 +69,7 @@ public:
     // Returns 0 when successful, -1 when the obsever is NULL or already added. 
     int subscribe(Observer* ob) {
         if (NULL == ob) {
-            LOG(ERROR) << "Observer is NULL";
+            //LOG(ERROR) << "Observer is NULL";
             return -1;
         }
         if (std::find(_obs.begin(), _obs.end(), ob) != _obs.end()) {
@@ -85,7 +85,7 @@ public:
     // Returns 0 when successful, -1 when the observer is NULL or already removed.
     int unsubscribe(Observer* ob) {
         if (NULL == ob) {
-            LOG(ERROR) << "Observer is NULL";
+            //LOG(ERROR) << "Observer is NULL";
             return -1;
         }
         typename ObserverSet::iterator
diff --git a/src/bvar/collector.cpp b/src/bvar/collector.cpp
index c7844c1..545f9b9 100644
--- a/src/bvar/collector.cpp
+++ b/src/bvar/collector.cpp
@@ -22,6 +22,7 @@
 #include "butil/memory/singleton_on_pthread_once.h"
 #include "bvar/bvar.h"
 #include "bvar/collector.h"
+#include "butil/logging.h"
 
 namespace bvar {
 
diff --git a/src/bvar/default_variables.cpp b/src/bvar/default_variables.cpp
index be02c50..aede053 100644
--- a/src/bvar/default_variables.cpp
+++ b/src/bvar/default_variables.cpp
@@ -37,6 +37,7 @@
 #include "butil/process_util.h"            // ReadCommandLine
 #include "butil/popen.h"                   // read_command_output
 #include "bvar/passive_status.h"
+#include "butil/logging.h"
 
 namespace bvar {
 
diff --git a/src/bvar/detail/agent_group.h b/src/bvar/detail/agent_group.h
index ceb7c05..6363a8d 100644
--- a/src/bvar/detail/agent_group.h
+++ b/src/bvar/detail/agent_group.h
@@ -31,7 +31,7 @@
 #include "butil/thread_local.h"              // thread_atexit
 #include "butil/macros.h"                    // BAIDU_CACHELINE_ALIGNMENT
 #include "butil/scoped_lock.h"
-#include "butil/logging.h"
+//#include "butil/logging.h"
 
 namespace bvar {
 namespace detail {
@@ -129,13 +129,13 @@ public:
     // Note: May return non-null for unexist id, see notes on ThreadBlock
     inline static Agent* get_or_create_tls_agent(AgentId id) {
         if (__builtin_expect(id < 0, 0)) {
-            CHECK(false) << "Invalid id=" << id;
+            //CHECK(false) << "Invalid id=" << id;
             return NULL;
         }
         if (_s_tls_blocks == NULL) {
             _s_tls_blocks = new (std::nothrow) std::vector<ThreadBlock *>;
             if (__builtin_expect(_s_tls_blocks == NULL, 0)) {
-                LOG(FATAL) << "Fail to create vector, " << berror();
+                //LOG(FATAL) << "Fail to create vector, " << berror();
                 return NULL;
             }
             butil::thread_atexit(_destroy_tls_blocks);
diff --git a/src/bvar/detail/combiner.h b/src/bvar/detail/combiner.h
index 6a6ab80..b01f7af 100644
--- a/src/bvar/detail/combiner.h
+++ b/src/bvar/detail/combiner.h
@@ -296,7 +296,7 @@ friend class GlobalValue<self_type>;
             // Create the agent
             agent = AgentGroup::get_or_create_tls_agent(_id);
             if (NULL == agent) {
-                LOG(FATAL) << "Fail to create agent";
+                //LOG(FATAL) << "Fail to create agent";
                 return NULL;
             }
         }
diff --git a/src/bvar/detail/percentile.h b/src/bvar/detail/percentile.h
index f04268d..48b6621 100644
--- a/src/bvar/detail/percentile.h
+++ b/src/bvar/detail/percentile.h
@@ -67,8 +67,8 @@ public:
             std::sort(_samples, _samples + saved_num);
             _sorted = true;
         }
-        CHECK_EQ(saved_num, _num_samples) << "You must call get_number() on"
-            " a unchanging PercentileInterval";
+        //CHECK_EQ(saved_num, _num_samples) << "You must call get_number() on"
+        //    " a unchanging PercentileInterval";
         return _samples[index];
     }
 
@@ -84,7 +84,7 @@ public:
         }
         BAIDU_CASSERT(SAMPLE_SIZE >= size2,
                       must_merge_small_interval_into_larger_one_currently);
-        CHECK_EQ(rhs._num_samples, rhs._num_added);
+        //CHECK_EQ(rhs._num_samples, rhs._num_added);
         // Assume that the probability of each sample in |this| is a0/b0 and
         // the probability of each sample in |rhs| is a1/b1.
         // We are going to randomly pick some samples from |this| and |rhs| to
@@ -97,13 +97,13 @@ public:
         // |b1*SAMPLE_SIZE/(b0+b1)| from |rhs|.
         if (_num_added + rhs._num_added <= SAMPLE_SIZE) {
             // No sample should be dropped
-            CHECK_EQ(_num_samples, _num_added)
-                << "_num_added=" << _num_added
-                << " rhs._num_added" << rhs._num_added
-                << " _num_samples=" << _num_samples
-                << " rhs._num_samples=" << rhs._num_samples
-                << " SAMPLE_SIZE=" << SAMPLE_SIZE
-                << " size2=" << size2;
+            //CHECK_EQ(_num_samples, _num_added)
+            //    << "_num_added=" << _num_added
+            //    << " rhs._num_added" << rhs._num_added
+            //    << " _num_samples=" << _num_samples
+            //    << " rhs._num_samples=" << rhs._num_samples
+            //    << " SAMPLE_SIZE=" << SAMPLE_SIZE
+            //    << " size2=" << size2;
             memcpy(_samples + _num_samples, rhs._samples, 
                    sizeof(_samples[0]) * rhs._num_samples);
             _num_samples += rhs._num_samples;
@@ -118,13 +118,13 @@ public:
             //    num_remain < SAMPLE_SIZE = _num_added
             size_t num_remain = round_of_expectation(
                     _num_added * SAMPLE_SIZE, _num_added + rhs._num_added);
-            CHECK_LE(num_remain, _num_samples);
+            //CHECK_LE(num_remain, _num_samples);
             // Randomly drop samples of this
             for (size_t i = _num_samples; i > num_remain; --i) {
                 _samples[butil::fast_rand_less_than(i)] = _samples[i - 1];
             }
             const size_t num_remain_from_rhs = SAMPLE_SIZE - num_remain;
-            CHECK_LE(num_remain_from_rhs, rhs._num_samples);
+            //CHECK_LE(num_remain_from_rhs, rhs._num_samples);
             // Have to copy data from rhs to shuffle since it's const
             DEFINE_SMALL_ARRAY(uint32_t, tmp, rhs._num_samples, 64);
             memcpy(tmp, rhs._samples, sizeof(uint32_t) * rhs._num_samples);
@@ -134,7 +134,7 @@ public:
                 tmp[index] = tmp[rhs._num_samples - i - 1];
             }
             _num_samples = num_remain;
-            CHECK_EQ(_num_samples, SAMPLE_SIZE);
+            //CHECK_EQ(_num_samples, SAMPLE_SIZE);
         }
         _num_added += rhs._num_added;
     }
@@ -142,7 +142,7 @@ public:
     // Randomly pick n samples from mutable_rhs to |this|
     template <size_t size2>
     void merge_with_expectation(PercentileInterval<size2>& mutable_rhs, size_t n) {
-        CHECK(n <= mutable_rhs._num_samples);
+        //CHECK(n <= mutable_rhs._num_samples);
         _num_added += mutable_rhs._num_added;
         if (_num_samples + n <= SAMPLE_SIZE && n == mutable_rhs._num_samples) {
             memcpy(_samples + _num_samples, mutable_rhs._samples, sizeof(_samples[0]) * n);
@@ -168,7 +168,7 @@ public:
     // Returns true if the input was stored.
     bool add32(uint32_t x) {
         if (BAIDU_UNLIKELY(_num_samples >= SAMPLE_SIZE)) {
-            LOG(ERROR) << "This interval was full";
+            //LOG(ERROR) << "This interval was full";
             return false;
         }
         ++_num_added;
@@ -309,7 +309,7 @@ friend class AddLatency;
             }
             n -= invl.added_count();
         }
-        CHECK(false) << "Can't reach here";
+        //CHECK(false) << "Can't reach here";
         return std::numeric_limits<uint32_t>::max();
     }
 
diff --git a/src/bvar/detail/sampler.cpp b/src/bvar/detail/sampler.cpp
index 3a14b37..85ca74c 100644
--- a/src/bvar/detail/sampler.cpp
+++ b/src/bvar/detail/sampler.cpp
@@ -23,6 +23,7 @@
 #include "bvar/detail/sampler.h"
 #include "bvar/passive_status.h"
 #include "bvar/window.h"
+#include "butil/logging.h"
 
 namespace bvar {
 namespace detail {
diff --git a/src/bvar/detail/sampler.h b/src/bvar/detail/sampler.h
index 85ec237..015865f 100644
--- a/src/bvar/detail/sampler.h
+++ b/src/bvar/detail/sampler.h
@@ -23,7 +23,7 @@
 #include <vector>
 #include "butil/containers/linked_list.h"// LinkNode
 #include "butil/scoped_lock.h"           // BAIDU_SCOPED_LOCK
-#include "butil/logging.h"               // LOG()
+//#include "butil/logging.h"               // LOG()
 #include "butil/containers/bounded_queue.h"// BoundedQueue
 #include "butil/type_traits.h"           // is_same
 #include "butil/time.h"                  // gettimeofday_us
@@ -73,7 +73,7 @@ friend class SamplerCollector;
 struct VoidOp {
     template <typename T>
     T operator()(const T&, const T&) const {
-        CHECK(false) << "This function should never be called, abort";
+        //CHECK(false) << "This function should never be called, abort";
         abort();
     }
 };
@@ -142,7 +142,7 @@ public:
 
     bool get_value(time_t window_size, Sample<T>* result) {
         if (window_size <= 0) {
-            LOG(FATAL) << "Invalid window_size=" << window_size;
+            //LOG(FATAL) << "Invalid window_size=" << window_size;
             return false;
         }
         BAIDU_SCOPED_LOCK(_mutex);
@@ -155,7 +155,7 @@ public:
             oldest = _q.top();
         }
         Sample<T>* latest = _q.bottom();
-        DCHECK(latest != oldest);
+        //DCHECK(latest != oldest);
         if (butil::is_same<InvOp, VoidOp>::value) {
             // No inverse op. Sum up all samples within the window.
             result->data = latest->data;
@@ -178,7 +178,7 @@ public:
     // Change the time window which can only go larger.
     int set_window_size(time_t window_size) {
         if (window_size <= 0 || window_size > MAX_SECONDS_LIMIT) {
-            LOG(ERROR) << "Invalid window_size=" << window_size;
+            //LOG(ERROR) << "Invalid window_size=" << window_size;
             return -1;
         }
         BAIDU_SCOPED_LOCK(_mutex);
@@ -190,7 +190,7 @@ public:
 
     void get_samples(std::vector<T> *samples, time_t window_size) {
         if (window_size <= 0) {
-            LOG(FATAL) << "Invalid window_size=" << window_size;
+            //LOG(FATAL) << "Invalid window_size=" << window_size;
             return;
         }
         BAIDU_SCOPED_LOCK(_mutex);
diff --git a/src/bvar/detail/series.h b/src/bvar/detail/series.h
index 3ceb913..b0a0c83 100644
--- a/src/bvar/detail/series.h
+++ b/src/bvar/detail/series.h
@@ -230,7 +230,7 @@ public:
 template <typename T, typename Op>
 void Series<T, Op>::describe(std::ostream& os,
                              const std::string* vector_names) const {
-    CHECK(vector_names == NULL);
+    //CHECK(vector_names == NULL);
     pthread_mutex_lock(&this->_mutex);
     const int second_begin = this->_nsecond;
     const int minute_begin = this->_nminute;
diff --git a/src/bvar/latency_recorder.cpp b/src/bvar/latency_recorder.cpp
index ed91422..7831d63 100644
--- a/src/bvar/latency_recorder.cpp
+++ b/src/bvar/latency_recorder.cpp
@@ -20,6 +20,7 @@
 #include <gflags/gflags.h>
 #include "butil/unique_ptr.h"
 #include "bvar/latency_recorder.h"
+#include "butil/logging.h"
 
 namespace bvar {
 
diff --git a/src/bvar/multi_dimension.h b/src/bvar/multi_dimension.h
new file mode 100644
index 0000000..068a982
--- /dev/null
+++ b/src/bvar/multi_dimension.h
@@ -0,0 +1,139 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Date: 2021/11/17 10:57:43
+
+#ifndef BVAR_MULTI_DIMENSION_H
+#define BVAR_MULTI_DIMENSION_H
+
+#include "butil/macros.h"                            // BAIDU_CASSERT
+#include "butil/scoped_lock.h"                       // BAIDU_SCOPE_LOCK
+#include "butil/containers/doubly_buffered_data.h"   // DBD
+#include "butil/containers/flat_map.h"               // butil::FlatMap
+#include "bvar/mvariable.h"
+
+namespace bvar {
+
+constexpr uint64_t MAX_MULTI_DIMENSION_STATS_COUNT = 20000;
+
+template <typename  T>
+class MultiDimension : public MVariable {
+public:
+
+    enum STATS_OP {
+        READ_ONLY,
+        READ_OR_INSERT,
+    };
+
+    typedef MVariable Base;
+    typedef std::list<std::string> key_type;
+    typedef T value_type;
+    typedef T* value_ptr_type;
+
+    struct KeyHash {
+        size_t operator() (const key_type& key) const {
+            size_t hash_value = 0;
+            for (auto &k : key) {
+                hash_value += std::hash<std::string>()(k);
+            }
+            return hash_value;
+        }
+    };
+    
+    typedef value_ptr_type op_value_type;
+    typedef typename butil::FlatMap<key_type, op_value_type, KeyHash> MetricMap;
+
+    typedef typename MetricMap::const_iterator MetricMapConstIterator;
+    typedef typename butil::DoublyBufferedData<MetricMap> MetricMapDBD;
+    typedef typename MetricMapDBD::ScopedPtr MetricMapScopedPtr;
+    
+    explicit MultiDimension(const key_type& labels);
+    
+    MultiDimension(const butil::StringPiece& name,
+                   const key_type& labels);
+    
+    MultiDimension(const butil::StringPiece& prefix,
+                   const butil::StringPiece& name,
+                   const key_type& labels);
+
+    ~MultiDimension();
+
+    // Implement this method to print the variable into ostream.
+    void describe(std::ostream& os);
+
+    // Dump real bvar pointer 
+    size_t dump(Dumper* dumper, const DumpOptions* options);
+
+    // Get real bvar pointer object
+    // Return real bvar pointer on success, NULL otherwise.
+    T* get_stats(const key_type& labels_value) {
+        return get_stats_impl(labels_value, READ_OR_INSERT);
+    }
+
+    // Get number of stats
+    size_t count_stats();
+
+    // Put name of all stats label into `names'
+    void list_stats(std::vector<key_type>* names);
+    
+#ifdef UNIT_TEST
+    // Get real bvar pointer object 
+    // Return real bvar pointer if labels_name exist, NULL otherwise.
+    // CAUTION!!! Just For Debug!!!
+    T* get_stats_read_only(const key_type& labels_value) {
+        return get_stats_impl(labels_value, READ_ONLY);
+    }
+
+    // Get real bvar pointer object 
+    // Return real bvar pointer if labels_name exist, otherwise(not exist) create bvar pointer.
+    // CAUTION!!! Just For Debug!!!
+    T* get_stats_read_or_insert(const key_type& labels_value, bool* do_write = NULL) {
+        return get_stats_impl(labels_value, READ_OR_INSERT, do_write);
+    }
+#endif
+
+    // Remove all stats so those not count and dump
+    // CAUTION!!! Just For Debug!!!
+    void delete_stats(const key_type& labels_value);
+
+private:
+    T* get_stats_impl(const key_type& labels_value, STATS_OP stats_op = READ_ONLY, bool* do_write = NULL);
+
+    void make_dump_key(std::ostream& os, 
+                       const key_type& labels_value, 
+                       const std::string& suffix = "", 
+                       const int quantile = 0);
+
+    void make_labels_kvpair_string(std::ostream& os, 
+                       const key_type& labels_value, 
+                       const int quantile);
+
+    bool is_valid_lables_value(const key_type& labels_value) const;
+    
+    void delete_stats();
+    
+    static size_t init_flatmap(MetricMap& bg);
+    
+private:
+    MetricMapDBD _metric_map;
+};
+
+} // namespace bvar
+
+#include "bvar/multi_dimension_inl.h"
+
+#endif // BVAR_MULTI_DIMENSION_H
diff --git a/src/bvar/multi_dimension_inl.h b/src/bvar/multi_dimension_inl.h
new file mode 100644
index 0000000..d63cc0a
--- /dev/null
+++ b/src/bvar/multi_dimension_inl.h
@@ -0,0 +1,367 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Date: 2021/11/17 10:57:43
+
+#ifndef BVAR_MULTI_DIMENSION_INL_H
+#define BVAR_MULTI_DIMENSION_INL_H
+
+#include <gflags/gflags_declare.h>
+
+namespace bvar {
+
+DECLARE_int32(bvar_latency_p1);
+DECLARE_int32(bvar_latency_p2);
+DECLARE_int32(bvar_latency_p3);
+
+static const std::string ALLOW_UNUSED METRIC_TYPE_COUNTER = "counter";
+static const std::string ALLOW_UNUSED METRIC_TYPE_SUMMARY = "summary";
+static const std::string ALLOW_UNUSED METRIC_TYPE_HISTOGRAM = "histogram";
+static const std::string ALLOW_UNUSED METRIC_TYPE_GAUGE = "gauge";
+
+template <typename T>
+inline
+MultiDimension<T>::MultiDimension(const key_type& labels)
+    : Base(labels)
+{
+    _metric_map.Modify(init_flatmap);
+}
+
+template <typename T>
+inline
+MultiDimension<T>::MultiDimension(const butil::StringPiece& name,
+                                  const key_type& labels)
+    : Base(labels)
+{
+    _metric_map.Modify(init_flatmap);
+    this->expose(name);
+}
+
+template <typename T>
+inline
+MultiDimension<T>::MultiDimension(const butil::StringPiece& prefix,
+                                  const butil::StringPiece& name,
+                                  const key_type& labels)
+    : Base(labels)
+{
+    _metric_map.Modify(init_flatmap);
+    this->expose_as(prefix, name);
+}
+
+template <typename T>
+MultiDimension<T>::~MultiDimension() {
+    delete_stats();
+    hide();
+}
+
+template <typename T>
+inline
+size_t MultiDimension<T>::init_flatmap(MetricMap& bg) {
+    // size = 1 << 13
+    //CHECK_EQ(0, bg.init(8192, 80));
+    bg.init(8192, 80);
+    return (size_t)1;
+}
+
+template <typename T>
+inline
+size_t MultiDimension<T>::count_stats() {
+    MetricMapScopedPtr metric_map_ptr;
+    if (_metric_map.Read(&metric_map_ptr) != 0) {
+        //LOG(ERROR) << "Fail to read dbd";
+        return 0;
+    }
+    return metric_map_ptr->size();
+}
+
+template <typename T>
+inline
+void MultiDimension<T>::delete_stats(const key_type& labels_value) {
+    if (is_valid_lables_value(labels_value)) {
+        // Because there are two copies(foreground and background) in DBD, we need to use an empty tmp_metric,
+        // get the deleted value of second copy into tmp_metric, which can prevent the bvar object from being deleted twice.
+        op_value_type tmp_metric = NULL;
+        auto fn = [&labels_value, &tmp_metric](MetricMap& bg) {
+            auto it = bg.seek(labels_value);
+            if (it != NULL) {
+                tmp_metric = *it;
+                bg.erase(labels_value);
+                return 1;
+            }
+            return 0;
+        };
+        _metric_map.Modify(fn);
+        if (tmp_metric) {
+            delete tmp_metric;
+        }
+    }
+}
+
+template <typename T>
+inline
+void MultiDimension<T>::delete_stats() {
+    // Because there are two copies(foreground and background) in DBD, we need to use an empty tmp_map,
+    // swap two copies with empty, and get the value of second copy into tmp_map,
+    // then traversal tmp_map and delete bvar object,
+    // which can prevent the bvar object from being deleted twice.
+    MetricMap tmp_map;
+    auto fn = [&tmp_map](MetricMap& map) {
+        if (!tmp_map.empty()) {
+            tmp_map.clear();
+        }
+        tmp_map.swap(map);
+        return (size_t)1;
+    };
+    int ret = _metric_map.Modify(fn);
+    //CHECK_EQ(1, ret);
+    for (auto &kv : tmp_map) {
+        delete kv.second;
+    }
+}
+
+template <typename T>
+inline
+void MultiDimension<T>::list_stats(std::vector<key_type>* names) {
+    if (names == NULL) {
+        return;
+    }
+    names->clear();
+    MetricMapScopedPtr metric_map_ptr;
+    if (_metric_map.Read(&metric_map_ptr) != 0) {
+        //LOG(ERROR) << "Fail to read dbd";
+        return;
+    }
+    names->reserve(metric_map_ptr->size());
+    for (auto it = metric_map_ptr->begin(); it != metric_map_ptr->end(); ++it) {
+        names->push_back(it->first);
+    }
+}
+
+template <typename T>
+inline
+T* MultiDimension<T>::get_stats_impl(const key_type& labels_value, STATS_OP stats_op, bool* do_write) {
+    if (!is_valid_lables_value(labels_value)) {
+        return nullptr;
+    }
+    {
+        MetricMapScopedPtr metric_map_ptr;
+        if (_metric_map.Read(&metric_map_ptr) != 0) {
+            //LOG(ERROR) << "Fail to read dbd";
+            return nullptr;
+        }
+
+        auto it = metric_map_ptr->seek(labels_value);
+        if (it != NULL) {
+            return (*it);
+        } else if (READ_ONLY == stats_op) {
+            return nullptr;
+        }
+
+        if (metric_map_ptr->size() > MAX_MULTI_DIMENSION_STATS_COUNT) {
+            //LOG(ERROR) << "Too many stats seen, overflow detected, max stats count:" << MAX_MULTI_DIMENSION_STATS_COUNT;
+            return nullptr;
+        }
+    }
+
+    // Because DBD has two copies(foreground and background) MetricMap, both copies need to be modify,
+    // In order to avoid new duplicate bvar object, need use cache_metric to cache the new bvar object,
+    // In this way, when modifying the second copy, can directly use the cache_metric bvar object.
+    op_value_type cache_metric = NULL;
+    auto fn = [&labels_value, &cache_metric, &do_write](MetricMap& bg) {
+        auto bg_metric = bg.seek(labels_value);
+        if (NULL != bg_metric) {
+            cache_metric = *bg_metric;
+            return 0;
+        }
+        if (do_write) {
+            *do_write = true;
+        }
+        if (NULL != cache_metric) {
+            bg[labels_value] = cache_metric;
+            // bg.insert({labels_value, cache_metric});
+        } else {
+            T* add_metric = new T();
+            bg[labels_value] = add_metric;
+            // bg.insert({labels_value, add_metric});
+            cache_metric = add_metric;
+        }
+        return 1;
+    };
+    _metric_map.Modify(fn);
+    return cache_metric;
+}
+
+template <typename T>
+inline
+size_t MultiDimension<T>::dump(Dumper* dumper, const DumpOptions* options) {
+    std::vector<key_type> label_names;
+    list_stats(&label_names);
+    if (label_names.empty() || !dumper->dump_comment(name(), METRIC_TYPE_GAUGE)) {
+        return 0;
+    }
+    std::vector<std::pair<std::string, std::string>> v;
+    for (auto &label_name : label_names) {
+        T* bvar = get_stats_impl(label_name);
+        if (!bvar) {
+            continue;
+        }
+        std::ostringstream oss;
+        bvar->describe(oss, options->quote_string);
+        std::ostringstream oss_key;
+        make_dump_key(oss_key, label_name);
+        v.push_back(std::make_pair(oss_key.str(), oss.str()));
+    }
+
+    return dumper->dumps(v);
+}
+
+template <>
+inline
+size_t MultiDimension<bvar::LatencyRecorder>::dump(Dumper* dumper, const DumpOptions*) {
+    std::vector<key_type> label_names;
+    list_stats(&label_names);
+    if (label_names.empty()) {
+        return 0;
+    }
+
+    std::vector<std::vector<std::pair<std::string, std::string>>> vv(4);
+    for (auto &label_name : label_names) {
+        bvar::LatencyRecorder* bvar = get_stats_impl(label_name);
+        if (!bvar) {
+            continue;
+        }
+
+        // latency comment
+        if (!dumper->dump_comment(name() + "_latency", METRIC_TYPE_GAUGE)) {
+            continue;
+        }
+        // latency
+        std::ostringstream oss_latency_key;
+        make_dump_key(oss_latency_key, label_name, "_latency");
+        vv[0].push_back(std::make_pair(oss_latency_key.str(), std::to_string(bvar->latency())));
+
+        // latency_percentiles
+        // p1/p2/p3
+        int latency_percentiles[3] {FLAGS_bvar_latency_p1, FLAGS_bvar_latency_p2, FLAGS_bvar_latency_p3};
+        for (auto lp : latency_percentiles) {
+            std::ostringstream oss_lp_key;
+            make_dump_key(oss_lp_key, label_name, "_latency", lp);
+            vv[0].push_back(std::make_pair(oss_lp_key.str(), std::to_string(bvar->latency_percentile(lp / 100.0))));
+        }
+        // 999
+        std::ostringstream oss_p999_key;
+        make_dump_key(oss_p999_key, label_name, "_latency", 999);
+        vv[0].push_back(std::make_pair(oss_p999_key.str(), std::to_string(bvar->latency_percentile(0.999))));
+
+        // 9999
+        std::ostringstream oss_p9999_key;
+        make_dump_key(oss_p9999_key, label_name, "_latency", 9999);
+        vv[0].push_back(std::make_pair(oss_p9999_key.str(), std::to_string(bvar->latency_percentile(0.9999))));
+
+        // max_latency comment
+        if (!dumper->dump_comment(name() + "_max_latency", METRIC_TYPE_GAUGE)) {
+            continue;
+        }
+        // max_latency
+        std::ostringstream oss_max_latency_key;
+        make_dump_key(oss_max_latency_key, label_name, "_max_latency");
+        vv[1].push_back(std::make_pair(oss_max_latency_key.str(), std::to_string(bvar->max_latency())));
+        
+        // qps comment
+        if (!dumper->dump_comment(name() + "_qps", METRIC_TYPE_GAUGE)) {
+            continue;
+        }
+        // qps
+        std::ostringstream oss_qps_key;
+        make_dump_key(oss_qps_key, label_name, "_qps");
+        vv[2].push_back(std::make_pair(oss_qps_key.str(), std::to_string(bvar->qps())));
+
+        // count comment
+        if (!dumper->dump_comment(name() + "_count", METRIC_TYPE_COUNTER)) {
+            continue;
+        }
+        // count
+        std::ostringstream oss_count_key;
+        make_dump_key(oss_count_key, label_name, "_count");
+        vv[3].push_back(std::make_pair(oss_count_key.str(), std::to_string(bvar->count())));
+    }
+
+    size_t n = 0;
+    for (auto& v : vv) {
+        n += dumper->dumps(v);
+    }
+    return n;
+}
+
+template <typename T>
+inline
+void MultiDimension<T>::make_dump_key(std::ostream& os, 
+                                      const key_type& labels_value,
+                                      const std::string& suffix,
+                                      const int quantile) {
+    os << name();
+    if (!suffix.empty()) {
+        os << suffix;
+    }
+    make_labels_kvpair_string(os, labels_value, quantile);
+}
+
+template <typename T>
+inline
+void MultiDimension<T>::make_labels_kvpair_string(std::ostream& os, 
+                                                  const key_type& labels_value, 
+                                                  const int quantile) {
+    os << "{";
+    auto label_key = _labels.cbegin();
+    auto label_value = labels_value.cbegin();
+    char comma[2] = {'\0', '\0'};
+    for (; label_key != _labels.cend() && label_value != labels_value.cend();
+        label_key++, label_value++) {
+        os << comma << label_key->c_str() << "=\"" << label_value->c_str() << "\"";
+        comma[0] = ',';
+    }
+    if (quantile > 0) {
+        os << ",quantile=\"" << quantile << "\"";
+    }
+    os << "}";
+}
+
+template <typename T>
+inline
+bool MultiDimension<T>::is_valid_lables_value(const key_type& labels_value) const {
+    if (count_labels() != labels_value.size()) {
+        //LOG(ERROR) << "Invalid labels count";
+        return false;
+    }
+    return true;
+}
+
+template <typename T>
+inline
+void MultiDimension<T>::describe(std::ostream& os) {
+    os << "{\"name\" : \"" << _name << "\", \"labels\" : [";
+    char comma[3] = {'\0', ' ', '\0'};
+    for (auto &label : _labels) {
+        os << comma << "\"" << label << "\"";
+        comma[0] = ',';
+    }
+    os << "], \"stats_count\" : " << count_stats() <<  "}";
+}
+
+} // namespace bvar
+
+#endif // BVAR_MULTI_DIMENSION_INL_H
diff --git a/src/bvar/mvariable.cpp b/src/bvar/mvariable.cpp
new file mode 100644
index 0000000..faac802
--- /dev/null
+++ b/src/bvar/mvariable.cpp
@@ -0,0 +1,253 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Date: 2021/11/17 14:37:53
+
+#include <gflags/gflags.h>
+#include <gflags/gflags_declare.h>
+#include "butil/logging.h"                       // LOG
+#include "butil/errno.h"                         // berror
+#include "butil/containers/flat_map.h"           // butil::FlatMap
+#include "butil/scoped_lock.h"                   // BAIDU_SCOPE_LOCK
+#include "butil/file_util.h"                     // butil::FilePath
+#include "bvar/variable.h"
+#include "bvar/mvariable.h"
+
+namespace bvar {
+
+constexpr uint64_t MAX_LABELS_COUNT = 10;
+
+DECLARE_bool(bvar_abort_on_same_name);
+
+extern bool s_bvar_may_abort;
+
+DEFINE_int32(bvar_max_multi_dimension_metric_number, 1024, "Max number of multi dimension");
+
+static bool validator_bvar_max_multi_dimension_metric_number(const char*, int32_t v) {
+    if (v < 1) {
+        LOG(ERROR) << "Invalid bvar_max_multi_dimension_metric_number=" << v;
+        return false;
+    }
+    return true;
+}
+
+const bool ALLOW_UNUSED dummp_bvar_max_multi_dimension_metric_number = ::GFLAGS_NS::RegisterFlagValidator(
+    &FLAGS_bvar_max_multi_dimension_metric_number, validator_bvar_max_multi_dimension_metric_number);
+
+class MVarEntry {
+public:
+    MVarEntry() : var(NULL) {}
+
+    MVariable* var;
+};
+
+typedef butil::FlatMap<std::string, MVarEntry> MVarMap;
+
+struct MVarMapWithLock : public MVarMap {
+    pthread_mutex_t mutex;
+
+    MVarMapWithLock() {
+        CHECK_EQ(0, init(256, 80));
+        pthread_mutex_init(&mutex, NULL);
+    }
+};
+
+// We have to initialize global map on need because bvar is possibly used
+// before main().
+static pthread_once_t s_mvar_map_once = PTHREAD_ONCE_INIT;
+static MVarMapWithLock* s_mvar_map = NULL;
+
+static void init_mvar_map() {
+    // It's probably slow to initialize all sub maps, but rpc often expose 
+    // variables before user. So this should not be an issue to users.
+    s_mvar_map = new MVarMapWithLock();
+}
+
+inline MVarMapWithLock& get_mvar_map() {
+    pthread_once(&s_mvar_map_once, init_mvar_map);
+    return *s_mvar_map;
+}
+
+MVariable::MVariable(const std::list<std::string>& labels) {
+    _labels.assign(labels.begin(), labels.end());
+    size_t n = labels.size();
+    if (n > MAX_LABELS_COUNT) {
+        LOG(ERROR) << "Too many labels: " << n << " seen, overflow detected, max labels count: " << MAX_LABELS_COUNT;
+        _labels.resize(MAX_LABELS_COUNT);
+    }
+}
+
+MVariable::~MVariable() {
+    CHECK(!hide()) << "Subclass of MVariable MUST call hide() manually in their"
+    " dtors to avoid displaying a variable that is just destructing";
+}
+
+std::string MVariable::get_description() {
+    std::ostringstream os;
+    describe(os);
+    return os.str();
+}
+
+int MVariable::describe_exposed(const std::string& name,
+                                std::ostream& os) {
+    MVarMapWithLock& m = get_mvar_map();
+    BAIDU_SCOPED_LOCK(m.mutex);
+    MVarEntry* entry = m.seek(name);
+    if (entry == NULL) {
+        return -1;
+    }
+    entry->var->describe(os);
+    return 0;
+}
+
+std::string MVariable::describe_exposed(const std::string& name) {
+    std::ostringstream oss;
+    if (describe_exposed(name, oss) == 0) {
+        return oss.str();
+    }
+    return std::string();
+}
+
+int MVariable::expose_impl(const butil::StringPiece& prefix,
+                           const butil::StringPiece& name) {
+    if (name.empty()) {
+        LOG(ERROR) << "Parameter[name] is empty";
+        return -1;
+    }
+    // NOTE: It's impossible to atomically erase from a submap and insert into
+    // another submap without a global lock. When the to-be-exposed name
+    // already exists, there's a chance that we can't insert back previous
+    // name. But it should be fine generally because users are unlikely to
+    // expose a variable more than once and calls to expose() are unlikely
+    // to contend heavily.
+
+    // remove previous pointer from the map if needed.
+    hide();
+    
+    // Build the name.
+    _name.clear();
+    _name.reserve((prefix.size() + name.size()) * 5 / 4);
+    if (!prefix.empty()) {
+        to_underscored_name(&_name, prefix);
+        if (!_name.empty() && butil::back_char(_name) != '_') {
+            _name.push_back('_');
+        }     
+    }
+    to_underscored_name(&_name, name);
+   
+    if (count_exposed() > (size_t)FLAGS_bvar_max_multi_dimension_metric_number) {
+        LOG(ERROR) << "Too many metric seen, overflow detected, max metric count:" << FLAGS_bvar_max_multi_dimension_metric_number;
+        return -1;
+    }
+
+    MVarMapWithLock& m = get_mvar_map();
+    {
+        BAIDU_SCOPED_LOCK(m.mutex);
+        MVarEntry* entry = m.seek(_name);
+        if (entry == NULL) {
+            entry = &m[_name];
+            entry->var = this;
+            return 0;
+        }
+    }
+
+    if (FLAGS_bvar_abort_on_same_name) {
+        LOG(FATAL) << "Abort due to name conflict";
+        abort();
+    } else if (!s_bvar_may_abort) {
+        // Mark name conflict occurs, If this conflict happens before
+        // initialization of bvar_abort_on_same_name, the validator will
+        // abort the program if needed.
+        s_bvar_may_abort = true;
+    }
+
+    LOG(FATAL) << "Already exposed `" << _name << "' whose describe is`"
+               << get_description() << "'";
+    _name.clear();
+    return 0;
+}
+
+bool MVariable::hide() {
+    if (_name.empty()) {
+        return false;
+    }
+
+    MVarMapWithLock& m = get_mvar_map();
+    BAIDU_SCOPED_LOCK(m.mutex);
+    MVarEntry* entry = m.seek(_name);
+    if (entry) {
+        CHECK_EQ(1UL, m.erase(_name));
+    } else {
+        CHECK(false) << "`" << _name << "' must exist";
+    }
+    _name.clear();
+    return true;
+}
+
+#ifdef UNIT_TEST
+void MVariable::hide_all() {
+    MVarMapWithLock& m = get_mvar_map();
+    BAIDU_SCOPED_LOCK(m.mutex);
+    m.clear();
+}
+#endif // end UNIT_TEST
+
+size_t MVariable::count_exposed() {
+    MVarMapWithLock& m = get_mvar_map();
+    BAIDU_SCOPED_LOCK(m.mutex);
+    return m.size();
+}
+
+void MVariable::list_exposed(std::vector<std::string>* names) {
+    if (names == NULL) {
+        return;
+    }
+
+    names->clear();
+
+    MVarMapWithLock& mvar_map = get_mvar_map();
+    BAIDU_SCOPED_LOCK(mvar_map.mutex);
+    names->reserve(mvar_map.size());
+    for (MVarMap::const_iterator it = mvar_map.begin(); it != mvar_map.end(); ++it) {
+        names->push_back(it->first);
+    }
+}
+
+size_t MVariable::dump_exposed(Dumper* dumper, const DumpOptions* options) {
+    if (NULL == dumper) {
+        LOG(ERROR) << "Parameter[dumper] is NULL";
+        return -1;
+    }
+    DumpOptions opt;
+    if (options) {
+        opt = *options;
+    }
+    std::vector<std::string> mvars;
+    list_exposed(&mvars);
+    size_t n = 0;
+    for (auto mvar : mvars) {
+        MVarMapWithLock& m = get_mvar_map();
+        BAIDU_SCOPED_LOCK(m.mutex);
+        MVarEntry* entry = m.seek(mvar);
+        if (entry) {
+            n += entry->var->dump(dumper, &opt);
+        }
+    }
+    return n;
+}
+
+} // namespace bvar
diff --git a/src/bvar/mvariable.h b/src/bvar/mvariable.h
new file mode 100644
index 0000000..28a3260
--- /dev/null
+++ b/src/bvar/mvariable.h
@@ -0,0 +1,125 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Date: 2021/11/17 14:37:53
+
+#ifndef BVAR_MVARIABLE_H
+#define BVAR_MVARIABLE_H
+
+#include <ostream>                      // std::ostream
+#include <sstream>                      // std::ostringstream
+#include <list>                         // std::list
+#include <string>                       // std::string
+#include "butil/macros.h"               // DISALLOW_COPY_AND_ASSIGN
+#include "butil/strings/string_piece.h" // butil::StringPiece
+
+namespace bvar {
+
+class Dumper;
+class DumpOptions;
+
+class MVariable {
+public:
+    explicit MVariable(const std::list<std::string>& labels);
+
+    virtual ~MVariable();
+
+    // Implement this method to print the mvariable info into ostream.
+    virtual void describe(std::ostream&) = 0;
+
+    // string form of describe().
+    std::string get_description();
+   
+    // Get mvariable name
+    const std::string& name() const { return _name; }
+    
+    // Get mvariable labels
+    const std::list<std::string>& labels() const { return _labels; }
+
+    // Get number of mvariable labels
+    size_t count_labels() const { return _labels.size(); }
+
+    // Expose this mvariable globally so that it's counted in following
+    // functions:
+    //      list_exposed
+    //      count_exposed
+    // Return 0 on success, -1 otherwise.
+    int expose(const butil::StringPiece& name) {
+        return expose_impl(butil::StringPiece(), name);
+    }
+
+    // Expose this mvariable globally with a prefix
+    // Return 0 on success, -1 otherwise.
+    int expose_as(const butil::StringPiece& prefix,
+                  const butil::StringPiece& name) {
+        return expose_impl(prefix, name);
+    }
+
+    // Dump this mvariable
+    virtual size_t dump(Dumper* dumper, const DumpOptions* options) = 0;
+
+    // Hide this variable so that it's not counted in *_exposed functions.
+    // Returns false if this variable is already hidden.
+    // CAUTION!! Subclasses must call hide() manually to avoid displaying
+    // a variable that is just destructing.
+    bool hide();
+
+    // Get number of exposed mvariables.
+    static size_t count_exposed();
+
+    // Put names of all exposed mvariable into `name'.
+    static void list_exposed(std::vector<std::string> *names);
+
+    // Find all exposed mvariables matching `white_wildcards' but
+    // `black_wildcards' and send them to `dumper'.
+    // Use default options when `options' is NULL.
+    // Return number of dumped mvariables, -1 on error.
+    static size_t dump_exposed(Dumper* dumper, const DumpOptions* options);
+
+    // Find an exposed mvariable by `name' and put its description into `os'.
+    // Returns 0 on found, -1 otherwise.
+    static int describe_exposed(const std::string& name,
+                                std::ostream& os);
+
+    // String form. Returns empty string when not found.
+    static std::string describe_exposed(const std::string& name);
+
+#ifdef UNIT_TEST
+    // Hide all mvariables so that all mvariables not counted in following
+    // functions:
+    //      list_exposed
+    //      count_exposed
+    // CAUTION!!! Just For Debug!!!
+    static void hide_all();
+#endif
+
+protected:
+    int expose_impl(const butil::StringPiece& prefix,
+                            const butil::StringPiece& name);
+
+protected:
+    std::string _name;
+    std::list<std::string>  _labels;
+
+    // mbvar uses bvar, bvar uses TLS, thus copying/assignment need to copy TLS stuff as well,
+    // which is heavy. We disable copying/assignment now. 
+    DISALLOW_COPY_AND_ASSIGN(MVariable);
+};
+
+} // namespace bvar
+
+#endif  // BVAR_MVARIABLE_H
diff --git a/src/bvar/passive_status.h b/src/bvar/passive_status.h
index eb4900d..8c6e361 100644
--- a/src/bvar/passive_status.h
+++ b/src/bvar/passive_status.h
@@ -162,7 +162,7 @@ public:
     }
 
     Tp reset() {
-        CHECK(false) << "PassiveStatus::reset() should never be called, abort";
+        //CHECK(false) << "PassiveStatus::reset() should never be called, abort";
         abort();
     }
 
diff --git a/src/bvar/recorder.h b/src/bvar/recorder.h
index 33bb65d..40572fe 100644
--- a/src/bvar/recorder.h
+++ b/src/bvar/recorder.h
@@ -22,7 +22,7 @@
 
 #include <stdint.h>                              // int64_t uint64_t
 #include "butil/macros.h"                         // BAIDU_CASSERT
-#include "butil/logging.h"                        // LOG
+//#include "butil/logging.h"                        // LOG
 #include "bvar/detail/combiner.h"                // detail::AgentCombiner
 #include "bvar/variable.h"
 #include "bvar/window.h"
@@ -245,22 +245,23 @@ inline IntRecorder& IntRecorder::operator<<(int64_t sample) {
             reason = "underflows";
             sample = std::numeric_limits<int>::min();
         }
+        (void)reason;
         // Truncate to be max or min of int. We're using 44 bits to store the
         // sum thus following aggregations are not likely to be over/underflow.
         if (!name().empty()) {
-            LOG(WARNING) << "Input=" << sample << " to `" << name()
-                       << "\' " << reason;
+            //LOG(WARNING) << "Input=" << sample << " to `" << name()
+            //           << "\' " << reason;
         } else if (!_debug_name.empty()) {
-            LOG(WARNING) << "Input=" << sample << " to `" << _debug_name
-                       << "\' " << reason;
+            //LOG(WARNING) << "Input=" << sample << " to `" << _debug_name
+            //           << "\' " << reason;
         } else {
-            LOG(WARNING) << "Input=" << sample << " to IntRecorder("
-                       << (void*)this << ") " << reason;
+            //LOG(WARNING) << "Input=" << sample << " to IntRecorder("
+            //           << (void*)this << ") " << reason;
         }
     }
     agent_type* agent = _combiner.get_or_create_tls_agent();
     if (BAIDU_UNLIKELY(!agent)) {
-        LOG(FATAL) << "Fail to create agent";
+        //LOG(FATAL) << "Fail to create agent";
         return *this;
     }
     uint64_t n;
diff --git a/src/bvar/reducer.h b/src/bvar/reducer.h
index fbd4fa7..f6eca68 100644
--- a/src/bvar/reducer.h
+++ b/src/bvar/reducer.h
@@ -21,7 +21,7 @@
 #define  BVAR_REDUCER_H
 
 #include <limits>                                 // std::numeric_limits
-#include "butil/logging.h"                         // LOG()
+//#include "butil/logging.h"                         // LOG()
 #include "butil/type_traits.h"                     // butil::add_cr_non_integral
 #include "butil/class_name.h"                      // class_name_str
 #include "bvar/variable.h"                        // Variable
@@ -115,10 +115,10 @@ public:
     // Notice that this function walks through threads that ever add values
     // into this reducer. You should avoid calling it frequently.
     T get_value() const {
-        CHECK(!(butil::is_same<InvOp, detail::VoidOp>::value) || _sampler == NULL)
-            << "You should not call Reducer<" << butil::class_name_str<T>()
-            << ", " << butil::class_name_str<Op>() << ">::get_value() when a"
-            << " Window<> is used because the operator does not have inverse.";
+        //CHECK(!(butil::is_same<InvOp, detail::VoidOp>::value) || _sampler == NULL)
+        //    << "You should not call Reducer<" << butil::class_name_str<T>()
+        //    << ", " << butil::class_name_str<Op>() << ">::get_value() when a"
+        //    << " Window<> is used because the operator does not have inverse.";
         return _combiner.combine_agents();
     }
 
@@ -193,7 +193,7 @@ inline Reducer<T, Op, InvOp>& Reducer<T, Op, InvOp>::operator<<(
     // It's wait-free for most time
     agent_type* agent = _combiner.get_or_create_tls_agent();
     if (__builtin_expect(!agent, 0)) {
-        LOG(FATAL) << "Fail to create agent";
+        //LOG(FATAL) << "Fail to create agent";
         return *this;
     }
     agent->element.modify(_combiner.op(), value);
diff --git a/src/bvar/utils/lock_timer.h b/src/bvar/utils/lock_timer.h
index f41024a..6a9b154 100644
--- a/src/bvar/utils/lock_timer.h
+++ b/src/bvar/utils/lock_timer.h
@@ -120,7 +120,7 @@ struct MutexConstructor<pthread_mutex_t> {
     bool operator()(pthread_mutex_t* mutex) const { 
 #ifndef NDEBUG
         const int rc = pthread_mutex_init(mutex, NULL);
-        CHECK_EQ(0, rc) << "Fail to init pthread_mutex, " << berror(rc);
+        //CHECK_EQ(0, rc) << "Fail to init pthread_mutex, " << berror(rc);
         return rc == 0;
 #else
         return pthread_mutex_init(mutex, NULL) == 0;
@@ -133,7 +133,7 @@ struct MutexDestructor<pthread_mutex_t> {
     bool operator()(pthread_mutex_t* mutex) const { 
 #ifndef NDEBUG
         const int rc = pthread_mutex_destroy(mutex);
-        CHECK_EQ(0, rc) << "Fail to destroy pthread_mutex, " << berror(rc);
+        //CHECK_EQ(0, rc) << "Fail to destroy pthread_mutex, " << berror(rc);
         return rc == 0;
 #else
         return pthread_mutex_destroy(mutex) == 0;
diff --git a/src/bvar/variable.cpp b/src/bvar/variable.cpp
index d9f7273..15cdf30 100644
--- a/src/bvar/variable.cpp
+++ b/src/bvar/variable.cpp
@@ -31,6 +31,8 @@
 #include "butil/file_util.h"                     // butil::FilePath
 #include "bvar/gflag.h"
 #include "bvar/variable.h"
+#include "butil/logging.h"
+#include "bvar/mvariable.h"
 
 namespace bvar {
 
@@ -44,7 +46,7 @@ DEFINE_bool(quote_vector, true,
 DEFINE_bool(bvar_abort_on_same_name, false,
             "Abort when names of bvar are same");
 // Remember abort request before bvar_abort_on_same_name is initialized.
-static bool s_bvar_may_abort = false;
+bool s_bvar_may_abort = false;
 static bool validate_bvar_abort_on_same_name(const char*, bool v) {
     if (v && s_bvar_may_abort) {
         // Name conflict happens before handling args of main(), this is
@@ -588,7 +590,9 @@ public:
             _fp = NULL;
         }
     }
-    bool dump(const std::string& name, const butil::StringPiece& desc) override {
+
+protected:
+    bool dump_impl(const std::string& name, const butil::StringPiece& desc, const std::string& separator) {
         if (_fp == NULL) {
             butil::File::Error error;
             butil::FilePath dir = butil::FilePath(_filename).DirName();
@@ -603,9 +607,10 @@ public:
                 return false;
             }
         }
-        if (fprintf(_fp, "%.*s%.*s : %.*s\r\n",
+        if (fprintf(_fp, "%.*s%.*s %.*s %.*s\r\n",
                     (int)_prefix.size(), _prefix.data(),
                     (int)name.size(), name.data(),
+                    (int)separator.size(), separator.data(),
                     (int)desc.size(), desc.data()) < 0) {
             PLOG(ERROR) << "Fail to write into " << _filename;
             return false;
@@ -613,12 +618,35 @@ public:
         return true;
     }
 private:
-
     std::string _filename;
     FILE* _fp;
     std::string _prefix;
 };
 
+class CommonFileDumper : public FileDumper {
+public:
+    CommonFileDumper(const std::string& filename, butil::StringPiece prefix)
+        : FileDumper(filename, prefix)
+        , _separator(":") {}
+    bool dump(const std::string& name, const butil::StringPiece& desc) {
+        return dump_impl(name, desc, _separator);
+    }
+private:
+    std::string _separator;
+};
+
+class PrometheusFileDumper : public FileDumper {
+public:
+    PrometheusFileDumper(const std::string& filename, butil::StringPiece prefix)
+        : FileDumper(filename, prefix)
+        , _separator(" ") {}
+    bool dump(const std::string& name, const butil::StringPiece& desc) {
+        return dump_impl(name, desc, _separator);
+    }
+private:
+    std::string _separator;
+};
+
 class FileDumperGroup : public Dumper {
 public:
     FileDumperGroup(std::string tabs, std::string filename, 
@@ -632,13 +660,13 @@ public:
         for (butil::KeyValuePairsSplitter sp(tabs, ';', '='); sp; ++sp) {
             std::string key = sp.key().as_string();
             std::string value = sp.value().as_string();
-            FileDumper *f = new FileDumper(
+            FileDumper *f = new CommonFileDumper(
                     path.AddExtension(key).AddExtension("data").value(), s);
             WildcardMatcher *m = new WildcardMatcher(value, '?', true);
             dumpers.emplace_back(f, m);
         }
         dumpers.emplace_back(
-                    new FileDumper(path.AddExtension("data").value(), s), 
+                    new CommonFileDumper(path.AddExtension("data").value(), s), 
                     (WildcardMatcher *)NULL);
     }
     ~FileDumperGroup() {
@@ -684,6 +712,13 @@ DEFINE_string(bvar_dump_tabs, "latency=*_latency*"
               "Dump bvar into different tabs according to the filters (seperated by semicolon), "
               "format: *(tab_name=wildcards;)");
 
+DEFINE_bool(mbvar_dump, false,
+            "Create a background thread dumping(shares the same thread as bvar_dump) all mbvar periodically, "
+            "all mbvar_dump_* flags are not effective when this flag is off");
+DEFINE_string(mbvar_dump_file, "monitor/mbvar.<app>.data", "Dump mbvar into this file");
+DEFINE_string(mbvar_dump_prefix, "<app>", "Every dumped name starts with this prefix");
+DEFINE_string(mbvar_dump_format, "common", "Dump mbvar write format");
+
 #if !defined(BVAR_NOT_LINK_DEFAULT_VARIABLES)
 // Expose bvar-releated gflags so that they're collected by noah.
 // Maybe useful when debugging process of monitoring.
@@ -696,12 +731,16 @@ static void* dumping_thread(void*) {
     // destructed when program exits and caused coredumps.
     const std::string command_name = read_command_name();
     std::string last_filename;
+    std::string mbvar_last_filename;
     while (1) {
         // We can't access string flags directly because it's thread-unsafe.
         std::string filename;
         DumpOptions options;
         std::string prefix;
         std::string tabs;
+        std::string mbvar_filename;
+        std::string mbvar_prefix;
+        std::string mbvar_format;
         if (!GFLAGS_NS::GetCommandLineOption("bvar_dump_file", &filename)) {
             LOG(ERROR) << "Fail to get gflag bvar_dump_file";
             return NULL;
@@ -725,6 +764,20 @@ static void* dumping_thread(void*) {
             return NULL;
         }
 
+        // We can't access string flags directly because it's thread-unsafe.
+        if (!GFLAGS_NS::GetCommandLineOption("mbvar_dump_file", &mbvar_filename)) {
+            LOG(ERROR) << "Fail to get gflag mbvar_dump_file";
+            return NULL;
+        }
+        if (!GFLAGS_NS::GetCommandLineOption("mbvar_dump_prefix", &mbvar_prefix)) {
+            LOG(ERROR) << "Fail to get gflag mbvar_dump_prefix";
+            return NULL;
+        }
+        if (!GFLAGS_NS::GetCommandLineOption("mbvar_dump_format", &mbvar_format)) {
+            LOG(ERROR) << "Fail to get gflag mbvar_dump_format";
+            return NULL;
+        }
+
         if (FLAGS_bvar_dump && !filename.empty()) {
             // Replace first <app> in filename with program name. We can't use
             // pid because a same binary should write the data to the same 
@@ -751,6 +804,41 @@ static void* dumping_thread(void*) {
             }
         }
 
+        // Dump multi dimension bvar
+        if (FLAGS_mbvar_dump && !mbvar_filename.empty()) {
+            // Replace first <app> in filename with program name. We can't use
+            // pid because a same binary should write the data to the same 
+            // place, otherwise restarting of app may confuse noah with a lot 
+            // of *.data. noah takes 1.5 days to figure out that some data is
+            // outdated and to be removed.
+            const size_t pos = mbvar_filename.find("<app>");
+            if (pos != std::string::npos) {
+                mbvar_filename.replace(pos, 5/*<app>*/, command_name);
+            }
+            if (mbvar_last_filename != mbvar_filename) {
+                mbvar_last_filename = mbvar_filename;
+                LOG(INFO) << "Write all mbvar to " << mbvar_filename << " every "
+                << FLAGS_bvar_dump_interval << " seconds.";
+            }
+            const size_t pos2 = mbvar_prefix.find("<app>");
+            if (pos2 != std::string::npos) {
+                mbvar_prefix.replace(pos2, 5/*<app>*/, command_name);
+            }
+
+            Dumper* dumper = NULL;
+            if ("common" == mbvar_format) {
+                dumper = new CommonFileDumper(mbvar_filename, mbvar_prefix);
+            } else if ("prometheus" == mbvar_format) {
+                dumper = new PrometheusFileDumper(mbvar_filename, mbvar_prefix);
+            }
+            int nline = MVariable::dump_exposed(dumper, &options);
+            if (nline < 0) {
+                LOG(ERROR) << "Fail to dump mvars into " << filename;
+            }
+            delete dumper;
+            dumper = NULL;
+        }
+
         // We need to separate the sleeping into a long interruptible sleep
         // and a short uninterruptible sleep. Doing this because we wake up
         // this thread in gflag validators. If this thread dumps just after
@@ -833,6 +921,29 @@ const bool ALLOW_UNUSED dummy_bvar_dump_prefix = ::GFLAGS_NS::RegisterFlagValida
 const bool ALLOW_UNUSED dummy_bvar_dump_tabs = ::GFLAGS_NS::RegisterFlagValidator(
     &FLAGS_bvar_dump_tabs, wakeup_dumping_thread);
 
+const bool ALLOW_UNUSED dummy_mbvar_dump = ::GFLAGS_NS::RegisterFlagValidator(
+    &FLAGS_mbvar_dump, validate_bvar_dump);
+const bool ALLOW_UNUSED dummy_mbvar_dump_prefix = ::GFLAGS_NS::RegisterFlagValidator(
+    &FLAGS_mbvar_dump_prefix, wakeup_dumping_thread);
+const bool ALLOW_UNUSED dump_mbvar_dump_file = ::GFLAGS_NS::RegisterFlagValidator(
+    &FLAGS_mbvar_dump_file, wakeup_dumping_thread);
+
+static bool validate_mbvar_dump_format(const char*, const std::string& format) {
+    if (format != "common"
+        && format != "prometheus") {
+        LOG(ERROR) << "Invalid mbvar_dump_format=" << format;
+        return false;
+    }
+
+    // We're modifying a flag, wake up dumping_thread to generate
+    // a new file soon.
+    pthread_cond_signal(&dump_cond);
+    return true;
+}
+
+const bool ALLOW_UNUSED dummy_mbvar_dump_format = ::GFLAGS_NS::RegisterFlagValidator(
+    &FLAGS_mbvar_dump_format, validate_mbvar_dump_format);
+
 void to_underscored_name(std::string* name, const butil::StringPiece& src) {
     name->reserve(name->size() + src.size() + 8/*just guess*/);
     for (const char* p = src.data(); p != src.data() + src.size(); ++p) {
diff --git a/src/bvar/variable.h b/src/bvar/variable.h
index 192484c..1ee4236 100644
--- a/src/bvar/variable.h
+++ b/src/bvar/variable.h
@@ -53,6 +53,19 @@ public:
     virtual ~Dumper() { }
     virtual bool dump(const std::string& name,
                       const butil::StringPiece& description) = 0;
+    virtual size_t dumps(const std::vector<std::pair<std::string, std::string>>& v) {
+        size_t n = 0;
+        for (auto& vi : v) {
+            if (dump(vi.first, vi.second)) {
+                n++;
+            }
+        }
+        return n;
+    }
+
+    virtual bool dump_comment(const std::string&, const std::string& /*type*/) {
+        return true;
+    }
 };
 
 // Options for Variable::dump_exposed().
diff --git a/src/bvar/window.h b/src/bvar/window.h
index a5780bf..a2cae43 100644
--- a/src/bvar/window.h
+++ b/src/bvar/window.h
@@ -23,7 +23,7 @@
 #include <limits>                                 // std::numeric_limits
 #include <math.h>                                 // round
 #include <gflags/gflags_declare.h>
-#include "butil/logging.h"                         // LOG
+//#include "butil/logging.h"                         // LOG
 #include "bvar/detail/sampler.h"
 #include "bvar/detail/series.h"
 #include "bvar/variable.h"
@@ -81,7 +81,7 @@ public:
         , _window_size(window_size > 0 ? window_size : FLAGS_bvar_dump_interval)
         , _sampler(var->get_sampler())
         , _series_sampler(NULL) {
-        CHECK_EQ(0, _sampler->set_window_size(_window_size));
+        _sampler->set_window_size(_window_size);
     }
     
     ~WindowBase() {
diff --git a/src/json2pb/pb_to_json.cpp b/src/json2pb/pb_to_json.cpp
index 55578c3..a45bc12 100644
--- a/src/json2pb/pb_to_json.cpp
+++ b/src/json2pb/pb_to_json.cpp
@@ -22,6 +22,8 @@
 #include <sys/time.h>
 #include <time.h>
 #include <google/protobuf/descriptor.h>
+#include <google/protobuf/util/json_util.h>
+#include <google/protobuf/util/type_resolver_util.h>
 #include "butil/base64.h"
 #include "zero_copy_stream_writer.h"
 #include "encode_decode.h"
@@ -333,4 +335,52 @@ bool ProtoMessageToJson(const google::protobuf::Message& message,
                         std::string* error) {
     return ProtoMessageToJson(message, stream, Pb2JsonOptions(), error);
 }
+
+// take from protobuf json_util.cc
+namespace {
+const char* kTypeUrlPrefix = "type.googleapis.com";
+google::protobuf::util::TypeResolver* generated_type_resolver_ = NULL;
+google::protobuf::internal::once_flag generated_type_resolver_init_;
+
+std::string GetTypeUrl(const google::protobuf::Message& message) {
+  return std::string(kTypeUrlPrefix) + "/" +
+         message.GetDescriptor()->full_name();
+}
+
+void DeleteGeneratedTypeResolver() { delete generated_type_resolver_; }
+
+void InitGeneratedTypeResolver() {
+  generated_type_resolver_ = google::protobuf::util::NewTypeResolverForDescriptorPool(
+      kTypeUrlPrefix, google::protobuf::DescriptorPool::generated_pool());
+  ::google::protobuf::internal::OnShutdown(&DeleteGeneratedTypeResolver);
+}
+
+google::protobuf::util::TypeResolver* GetGeneratedTypeResolver() {
+  google::protobuf::internal::call_once(generated_type_resolver_init_,
+                                        InitGeneratedTypeResolver);
+  return generated_type_resolver_;
+}
+}  // namespace
+
+google::protobuf::util::Status ProtoMessageToJsonWithWellKnownType(const google::protobuf::Message& message,
+                                                                   google::protobuf::io::ZeroCopyOutputStream *json)
+{
+    const google::protobuf::DescriptorPool* pool = message.GetDescriptor()->file()->pool();
+    google::protobuf::util::TypeResolver* resolver =
+        pool == google::protobuf::DescriptorPool::generated_pool()
+            ? GetGeneratedTypeResolver()
+            : google::protobuf::util::NewTypeResolverForDescriptorPool(kTypeUrlPrefix, pool);
+
+    std::string binary_input = std::move(message.SerializeAsString());
+    google::protobuf::io::ArrayInputStream input_stream(binary_input.data(), binary_input.size());
+
+    google::protobuf::util::Status result =
+        google::protobuf::util::BinaryToJsonStream(resolver, GetTypeUrl(message),
+                           &input_stream, json, google::protobuf::util::JsonPrintOptions());
+    if (pool != google::protobuf::DescriptorPool::generated_pool()) {
+        delete resolver;
+    }
+    return result;
+}
+
 } // namespace json2pb
diff --git a/src/json2pb/pb_to_json.h b/src/json2pb/pb_to_json.h
index 3fbc6c4..2b71f03 100644
--- a/src/json2pb/pb_to_json.h
+++ b/src/json2pb/pb_to_json.h
@@ -23,6 +23,7 @@
 #include <string>
 #include <google/protobuf/message.h>
 #include <google/protobuf/io/zero_copy_stream.h> // ZeroCopyOutputStream
+#include <google/protobuf/stubs/status.h>
 
 namespace json2pb {
 
@@ -86,6 +87,10 @@ bool ProtoMessageToJson(const google::protobuf::Message& message,
 bool ProtoMessageToJson(const google::protobuf::Message& message,
                         google::protobuf::io::ZeroCopyOutputStream* json,
                         std::string* error = NULL);
+
+google::protobuf::util::Status ProtoMessageToJsonWithWellKnownType(const google::protobuf::Message& message,
+                                                                   google::protobuf::io::ZeroCopyOutputStream *json);
+
 } // namespace json2pb
 
 #endif // BRPC_JSON2PB_PB_TO_JSON_H
diff --git a/test/bvar_multi_dimension_unittest.cpp b/test/bvar_multi_dimension_unittest.cpp
new file mode 100644
index 0000000..c40e5bb
--- /dev/null
+++ b/test/bvar_multi_dimension_unittest.cpp
@@ -0,0 +1,471 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Date 2021/11/17 14:57:49
+
+#include <pthread.h>
+#include <cstddef>
+#include <memory>
+#include <iostream>
+#include <set>
+#include <string>
+#include <gflags/gflags.h>
+#include <gtest/gtest.h>
+#include "butil/time.h"
+#include "butil/macros.h"
+#include "bvar/bvar.h"
+#include "bvar/multi_dimension.h"
+#include "butil/third_party/rapidjson/rapidjson.h"
+#include "butil/third_party/rapidjson/document.h"
+
+const size_t OPS_PER_THREAD = 200000;
+
+const size_t OPS_PER_THREAD_INTRECORDER = 2000;
+
+static const int num_thread = 24;
+
+static const int idc_count = 20;
+static const int method_count = 20;
+static const int status_count = 50;
+
+static const std::list<std::string> labels = {"idc", "method", "status"};
+
+static void *thread_adder(void *arg) {
+    bvar::Adder<uint64_t> *reducer = (bvar::Adder<uint64_t> *)arg;
+    butil::Timer timer;
+    timer.start();
+    for (size_t i = 0; i < OPS_PER_THREAD; ++i) {
+        (*reducer) << 2;
+    }
+    timer.stop();
+    return (void *)(timer.n_elapsed());
+}
+
+static long start_perf_test_with_madder(size_t num_thread, bvar::Adder<uint64_t>* adder) {
+    EXPECT_TRUE(adder->valid());
+    pthread_t threads[num_thread];
+    for (size_t i = 0; i < num_thread; ++i) {
+        pthread_create(&threads[i], NULL, &thread_adder, (void *)adder);
+    }
+    long totol_time = 0;
+    for (size_t i = 0; i < num_thread; ++i) {
+        void *ret = NULL; 
+        pthread_join(threads[i], &ret);
+        totol_time += (long)ret;
+    }
+    long avg_time = totol_time / (OPS_PER_THREAD * num_thread);
+    EXPECT_EQ(2ul * num_thread * OPS_PER_THREAD, adder->get_value());
+    return avg_time;
+}
+
+static void *thread_maxer(void *arg) {
+    bvar::Maxer<uint64_t> *reducer = (bvar::Maxer<uint64_t> *)arg;
+    butil::Timer timer;
+    timer.start();
+    for (size_t i = 1; i <= OPS_PER_THREAD; ++i) {
+        (*reducer) << 2 * i * OPS_PER_THREAD;
+    }
+    timer.stop();
+    return (void *)(timer.n_elapsed());
+}
+
+static long start_perf_test_with_mmaxer(size_t num_thread, bvar::Maxer<uint64_t>* maxer) {
+    EXPECT_TRUE(maxer->valid());
+    pthread_t threads[num_thread];
+    for (size_t i = 0; i < num_thread; ++i) {
+        pthread_create(&threads[i], NULL, &thread_maxer, (void *)maxer);
+    }
+    long totol_time = 0;
+    for (size_t i = 0; i < num_thread; ++i) {
+        void *ret = NULL; 
+        pthread_join(threads[i], &ret);
+        totol_time += (long)ret;
+    }
+    long avg_time = totol_time / (OPS_PER_THREAD * num_thread);
+    EXPECT_EQ(2ul * OPS_PER_THREAD * OPS_PER_THREAD, maxer->get_value());
+    return avg_time;
+}
+
+static void *thread_miner(void *arg) {
+    bvar::Miner<uint64_t> *reducer = (bvar::Miner<uint64_t> *)arg;
+    butil::Timer timer;
+    timer.start();
+    for (size_t i = 1; i <= OPS_PER_THREAD; ++i) {
+        (*reducer) << -2 * i * OPS_PER_THREAD;
+    }
+    timer.stop();
+    return (void *)(timer.n_elapsed());
+}
+
+static long start_perf_test_with_mminer(size_t num_thread, bvar::Miner<uint64_t>* miner) {
+    EXPECT_TRUE(miner->valid());
+    pthread_t threads[num_thread];
+    for (size_t i = 0; i < num_thread; ++i) {
+        pthread_create(&threads[i], NULL, &thread_miner, (void *)miner);
+    }
+    long totol_time = 0;
+    for (size_t i = 0; i < num_thread; ++i) {
+        void *ret = NULL; 
+        pthread_join(threads[i], &ret);
+        totol_time += (long)ret;
+    }
+    long avg_time = totol_time / (OPS_PER_THREAD * num_thread);
+    EXPECT_EQ(-2ul * OPS_PER_THREAD * OPS_PER_THREAD, miner->get_value());
+    return avg_time;
+}
+
+static void *thread_intrecorder(void *arg) {
+    bvar::IntRecorder *reducer = (bvar::IntRecorder *)arg;
+    butil::Timer timer;
+    timer.start();
+    for (size_t i = 1; i <= OPS_PER_THREAD_INTRECORDER; ++i) {
+        (*reducer) << 2 * i * OPS_PER_THREAD_INTRECORDER;
+    }
+    timer.stop();
+    return (void *)(timer.n_elapsed());
+}
+
+static long start_perf_test_with_mintrecorder(size_t num_thread, bvar::IntRecorder* intrecorder) {
+    EXPECT_TRUE(intrecorder->valid());
+    pthread_t threads[num_thread];
+    for (size_t i = 0; i < num_thread; ++i) {
+        pthread_create(&threads[i], NULL, &thread_intrecorder, (void *)intrecorder);
+    }
+    long totol_time = 0;
+    for (size_t i = 0; i < num_thread; ++i) {
+        void *ret = NULL; 
+        pthread_join(threads[i], &ret);
+        totol_time += (long)ret;
+    }
+    long avg_time = totol_time / (OPS_PER_THREAD_INTRECORDER * num_thread);
+    EXPECT_EQ(2ul * (1 + OPS_PER_THREAD_INTRECORDER) / 2 * OPS_PER_THREAD_INTRECORDER, intrecorder->average());
+    return avg_time;
+}
+
+class MultiDimensionTest : public testing::Test {
+protected:
+    void SetUp() {}
+    void TearDown() {
+    }
+};
+
+TEST_F(MultiDimensionTest, madder) {
+    std::list<std::string> labels_value = {"bj", "get", "200"};
+    bvar::MultiDimension<bvar::Adder<uint32_t> > my_madder1("request_count_madder_uint32_t", labels);
+    bvar::Adder<uint32_t>* my_adder1 = my_madder1.get_stats(labels_value);
+    ASSERT_TRUE(my_adder1);
+    ASSERT_TRUE(my_adder1->valid());
+    *my_adder1 << 2 << 4;
+    ASSERT_EQ(6u, my_adder1->get_value());
+
+    bvar::MultiDimension<bvar::Adder<double> > my_madder2("request_count_madder_double", labels);
+    bvar::Adder<double>* my_adder2 = my_madder2.get_stats(labels_value);
+    ASSERT_TRUE(my_adder2);
+    ASSERT_TRUE(my_adder2->valid());
+    *my_adder2 <<  2.0 << 4.0;
+    ASSERT_EQ(6.0, my_adder2->get_value());
+
+    bvar::MultiDimension<bvar::Adder<int> > my_madder3("request_count_madder_int", labels);
+    bvar::Adder<int>* my_adder3 = my_madder3.get_stats(labels_value);
+    ASSERT_TRUE(my_adder3);
+    ASSERT_TRUE(my_adder3->valid());
+    *my_adder3 << -9 << 1 << 0 << 3;
+    ASSERT_EQ(-5, my_adder3->get_value());
+
+    bvar::MultiDimension<bvar::Adder<std::string> > my_madder_str("my_string", labels);
+    bvar::Adder<std::string> *my_str1 = my_madder_str.get_stats(labels_value);
+    ASSERT_TRUE(my_str1);
+    std::string str1 = "world";
+    *my_str1 << "hello " << str1;
+    ASSERT_STREQ("hello world", my_str1->get_value().c_str());
+}
+
+TEST_F(MultiDimensionTest, mmadder_perf) {
+    std::list<std::string> labels_value = {"bj", "get", "200"};
+    bvar::MultiDimension<bvar::Adder<uint64_t> > my_madder1("request_count_madder_uint64_t", labels);
+    bvar::Adder<uint64_t>* my_adder = my_madder1.get_stats(labels_value);
+    ASSERT_TRUE(my_adder);
+    
+    std::ostringstream oss;
+    for (size_t i = 1; i <= num_thread; ++i) { 
+        my_adder->reset();
+        oss << i << '\t' << start_perf_test_with_madder(i, my_adder) << '\n';
+    }
+    LOG(INFO) << "Adder performance:\n" << oss.str();
+}
+
+TEST_F(MultiDimensionTest, mmaxer) {
+    bvar::MultiDimension<bvar::Maxer<int> > my_mmaxer("request_count_mmaxer", labels);
+    std::list<std::string> labels_value = {"bj", "get", "200"};
+    bvar::Maxer<int>* my_maxer = my_mmaxer.get_stats(labels_value);
+    ASSERT_TRUE(my_maxer);
+    *my_maxer << 1 << 2 << 3;
+    ASSERT_EQ(3, my_maxer->get_value());
+}
+
+TEST_F(MultiDimensionTest, mmaxer_perf) {
+    bvar::MultiDimension<bvar::Maxer<uint64_t> > my_mmaxer("request_count_mmaxer", labels);
+    std::list<std::string> labels_value = {"bj", "get", "200"};
+    bvar::Maxer<uint64_t>* my_maxer = my_mmaxer.get_stats(labels_value);
+    ASSERT_TRUE(my_maxer);
+    
+    std::ostringstream oss;
+    for (size_t i = 1; i <= num_thread; ++i) { 
+        my_maxer->reset();
+        oss << i << '\t' << start_perf_test_with_mmaxer(i, my_maxer) << '\n';
+    }
+    LOG(INFO) << "Maxer performance:\n" << oss.str();
+}
+
+TEST_F(MultiDimensionTest, mminer) {
+    bvar::MultiDimension<bvar::Miner<int> > my_mminer("client_request_count_mminer", labels);
+    std::list<std::string> labels_value = {"bj", "get", "200"};
+    bvar::Miner<int>* my_miner = my_mminer.get_stats(labels_value);
+    ASSERT_TRUE(my_miner);
+    *my_miner << 1 << 2 << 3;
+    ASSERT_EQ(1, my_miner->get_value());
+}
+
+TEST_F(MultiDimensionTest, mminer_perf) {
+    bvar::MultiDimension<bvar::Miner<uint64_t> > my_mminer("request_count_mminer", labels);
+    std::list<std::string> labels_value = {"bj", "get", "200"};
+    bvar::Miner<uint64_t>* my_miner = my_mminer.get_stats(labels_value);
+    ASSERT_TRUE(my_miner);
+    
+    std::ostringstream oss;
+    for (size_t i = 1; i <= num_thread; ++i) { 
+        my_miner->reset();
+        oss << i << '\t' << start_perf_test_with_mminer(i, my_miner) << '\n';
+    }
+    LOG(INFO) << "Miner performance:\n" << oss.str();
+}
+
+
+TEST_F(MultiDimensionTest, mintrecoder) {
+    bvar::MultiDimension<bvar::IntRecorder> my_mintrecorder("client_request_count_mintrecorder", labels);
+    std::list<std::string> labels_value = {"bj", "get", "200"};
+    bvar::IntRecorder* my_intrecorder = my_mintrecorder.get_stats(labels_value);
+    ASSERT_TRUE(my_intrecorder);
+    *my_intrecorder << 1 << 2 << 3;
+    ASSERT_EQ(2, my_intrecorder->average());
+}
+
+TEST_F(MultiDimensionTest, mintrecorder_perf) {
+    bvar::MultiDimension<bvar::IntRecorder> my_mintrecorder("request_count_mintrecorder", labels);
+    std::list<std::string> labels_value = {"bj", "get", "200"};
+    bvar::IntRecorder* my_intrecorder = my_mintrecorder.get_stats(labels_value);
+    ASSERT_TRUE(my_intrecorder);
+    
+    std::ostringstream oss;
+    for (size_t i = 1; i <= num_thread; ++i) { 
+        my_intrecorder->reset();
+        oss << i << '\t' << start_perf_test_with_mintrecorder(i, my_intrecorder) << '\n';
+    }
+    LOG(INFO) << "IntRecorder performance:\n" << oss.str();
+}
+
+TEST_F(MultiDimensionTest, stats) {
+    std::vector<std::list<std::string> > vec_labels;
+    std::vector<std::list<std::string> > vec_labels_no_sort;
+    bvar::MultiDimension<bvar::Adder<int> > my_madder("test_stats", labels);
+    std::list<std::string> labels_value1 = {"tc", "get", "200"};
+    vec_labels.push_back(labels_value1);
+    vec_labels_no_sort.push_back(labels_value1);
+    bvar::Adder<int>* adder1 = my_madder.get_stats(labels_value1);
+    ASSERT_TRUE(adder1);
+    std::vector<std::list<std::string> > ret_labels;
+    my_madder.list_stats(&ret_labels);
+    ASSERT_EQ(vec_labels, ret_labels);
+
+    std::list<std::string> labels_value2 = {"nj", "get", "200"};
+    bvar::Adder<int>* adder2 = my_madder.get_stats(labels_value2);
+    ASSERT_TRUE(adder2);
+    vec_labels.push_back(labels_value2);
+    vec_labels_no_sort.push_back(labels_value2);
+    my_madder.list_stats(&ret_labels);
+    sort(vec_labels.begin(), vec_labels.end());
+    sort(ret_labels.begin(), ret_labels.end());
+    ASSERT_EQ(vec_labels, ret_labels);
+
+    std::list<std::string> labels_value3 = {"hz", "post", "500"};
+    bvar::Adder<int>* adder3 = my_madder.get_stats(labels_value3);
+    ASSERT_TRUE(adder3);
+    vec_labels.push_back(labels_value3);
+    vec_labels_no_sort.push_back(labels_value3);
+    my_madder.list_stats(&ret_labels);
+    sort(vec_labels.begin(), vec_labels.end());
+    sort(ret_labels.begin(), ret_labels.end());
+    ASSERT_EQ(vec_labels, ret_labels);
+
+    std::list<std::string> labels_value4 = {"gz", "post", "500"};
+    bvar::Adder<int>* adder4 = my_madder.get_stats(labels_value4);
+    ASSERT_TRUE(adder4);
+    ASSERT_EQ(4, my_madder.count_stats());
+    vec_labels.push_back(labels_value4);
+    vec_labels_no_sort.push_back(labels_value4);
+    my_madder.list_stats(&ret_labels);
+    sort(vec_labels.begin(), vec_labels.end());
+    sort(ret_labels.begin(), ret_labels.end());
+    ASSERT_EQ(vec_labels, ret_labels);
+
+    my_madder.delete_stats(labels_value4);
+    ASSERT_EQ(3, my_madder.count_stats());
+    vec_labels_no_sort.pop_back();
+    my_madder.list_stats(&ret_labels);
+    sort(vec_labels_no_sort.begin(), vec_labels_no_sort.end());
+    sort(ret_labels.begin(), ret_labels.end());
+    ASSERT_EQ(vec_labels_no_sort, ret_labels);
+}
+
+TEST_F(MultiDimensionTest, get_description) {
+    bvar::MultiDimension<bvar::Adder<int> > my_madder("test_get_description", labels);
+    std::list<std::string> labels_value1 = {"gz", "post", "200"};
+    bvar::Adder<int>* adder1 = my_madder.get_stats(labels_value1);
+    ASSERT_TRUE(adder1);
+    *adder1 << 1;
+    std::list<std::string> labels_value2 = {"tc", "post", "200"};
+    bvar::Adder<int>* adder2 = my_madder.get_stats(labels_value2);
+    ASSERT_TRUE(adder2);
+    *adder2 << 2;
+
+    const std::string description = my_madder.get_description();
+    LOG(INFO) << "description=" << description;
+    BUTIL_RAPIDJSON_NAMESPACE::Document doc;
+    doc.Parse(description.c_str());
+    ASSERT_FALSE(doc.HasParseError());
+    ASSERT_TRUE(doc.IsObject());
+    ASSERT_TRUE(doc.HasMember("name"));
+    ASSERT_TRUE(doc["name"].IsString());
+    ASSERT_STREQ("test_get_description", doc["name"].GetString());
+
+    ASSERT_TRUE(doc.HasMember("stats_count"));
+    ASSERT_TRUE(doc["stats_count"].IsInt());
+    ASSERT_EQ(2, doc["stats_count"].GetInt());
+
+    ASSERT_TRUE(doc.HasMember("labels"));
+    ASSERT_TRUE(doc["labels"].IsArray());
+
+    BUTIL_RAPIDJSON_NAMESPACE::Value& labels = doc["labels"];
+    ASSERT_EQ(3, labels.Size());
+    ASSERT_STREQ(labels[0].GetString(), "idc");
+    ASSERT_STREQ(labels[1].GetString(), "method");
+    ASSERT_STREQ(labels[2].GetString(), "status");
+}
+
+TEST_F(MultiDimensionTest, mlatencyrecorder) {
+    std::string old_bvar_dump_interval;
+    std::string old_mbvar_dump;
+    std::string old_bvar_latency_p1;
+    std::string old_bvar_latency_p2;
+    std::string old_bvar_latency_p3;
+
+    GFLAGS_NS::GetCommandLineOption("bvar_dump_interval", &old_bvar_dump_interval);
+    GFLAGS_NS::GetCommandLineOption("mbvar_dump", &old_mbvar_dump);
+    GFLAGS_NS::GetCommandLineOption("bvar_latency_p1", &old_bvar_latency_p1);
+    GFLAGS_NS::GetCommandLineOption("bvar_latency_p2", &old_bvar_latency_p2);
+    GFLAGS_NS::GetCommandLineOption("bvar_latency_p3", &old_bvar_latency_p3);
+
+    GFLAGS_NS::SetCommandLineOption("bvar_dump_interval", "1");
+    GFLAGS_NS::SetCommandLineOption("mbvar_dump", "true");
+    GFLAGS_NS::SetCommandLineOption("bvar_latency_p1", "60");
+    GFLAGS_NS::SetCommandLineOption("bvar_latency_p2", "70");
+    GFLAGS_NS::SetCommandLineOption("bvar_latency_p3", "80");
+
+    bvar::MultiDimension<bvar::LatencyRecorder> my_mlatencyrecorder("client_request_count_mlatencyrecorder", labels);
+    std::list<std::string> labels_value = {"tc", "get", "200"};
+    bvar::LatencyRecorder* my_latencyrecorder = my_mlatencyrecorder.get_stats(labels_value);
+    ASSERT_TRUE(my_latencyrecorder);
+    *my_latencyrecorder << 1 << 2 << 3 << 4 << 5 << 6 << 7;
+    sleep(1);
+    ASSERT_EQ(4, my_latencyrecorder->latency());
+    ASSERT_EQ(7, my_latencyrecorder->max_latency());
+    ASSERT_LE(7, my_latencyrecorder->qps());
+    ASSERT_EQ(7, my_latencyrecorder->count());
+
+    GFLAGS_NS::SetCommandLineOption("bvar_dump_interval", old_bvar_dump_interval.c_str());
+    GFLAGS_NS::SetCommandLineOption("mbvar_dump", old_mbvar_dump.c_str());
+    GFLAGS_NS::SetCommandLineOption("bvar_latency_p1", old_bvar_latency_p1.c_str());
+    GFLAGS_NS::SetCommandLineOption("bvar_latency_p2", old_bvar_latency_p2.c_str());
+    GFLAGS_NS::SetCommandLineOption("bvar_latency_p3", old_bvar_latency_p3.c_str());
+}
+
+TEST_F(MultiDimensionTest, mstatus) {
+    bvar::MultiDimension<bvar::Status<int> > my_mstatus("my_mstatus", labels);
+    std::list<std::string> labels_value {"tc", "get", "200"};
+    bvar::Status<int>* my_status = my_mstatus.get_stats(labels_value);
+    ASSERT_TRUE(my_status);
+    my_status->set_value(1);
+    ASSERT_EQ(1, my_status->get_value());
+}
+
+typedef size_t (*hash_fun)(const std::list<std::string>& labels_name);
+
+static uint64_t perf_hash(hash_fun fn) {
+    uint64_t cost = 0;
+    for (int i = 0; i < idc_count; i++) {
+        std::ostringstream oss_idc;
+        oss_idc << "idc" << i;
+        for (int j = 0; j < method_count; j++) {
+            std::ostringstream oss_method;
+            oss_method << "method" << j;
+            for (int k = 0; k < status_count; k++) {
+                std::ostringstream oss_status;
+                oss_status << "status" << k;
+                std::list<std::string> labels_value {oss_idc.str(), oss_method.str(), oss_status.str()};
+                butil::Timer timer(butil::Timer::STARTED);
+                size_t hash_code = fn(labels_value);
+                EXPECT_NE(0, hash_code);
+                timer.stop();
+                cost += timer.n_elapsed();
+            }
+        }
+    }
+    return cost;
+}
+
+static size_t hash_fun1(const std::list<std::string>& labels_value) {
+    size_t hash_value = 0;
+    for (auto &k : labels_value) {
+        hash_value += std::hash<std::string>()(k);
+    }
+    return hash_value;
+}
+
+static size_t hash_fun2(const std::list<std::string>& labels_value) {
+    std::string hash_str;
+    for (auto &k : labels_value) {
+        hash_str.append(k);
+    }
+    return std::hash<std::string>()(hash_str);
+}
+
+static size_t hash_fun3(const std::list<std::string>& labels_value) {
+    std::ostringstream oss;
+    for (auto &k : labels_value) {
+        oss << k;
+    }
+    return std::hash<std::string>()(oss.str());
+}
+
+TEST_F(MultiDimensionTest, test_hash) {
+    std::ostringstream oss;
+    oss << "hash_fun1 \t" << perf_hash(hash_fun1) << "\n"
+        << "hash_fun2 \t" << perf_hash(hash_fun2) << "\n"
+        << "hash_fun3 \t" << perf_hash(hash_fun3) << "\n";
+    LOG(INFO) << "Hash fun performance:\n" << oss.str();
+}
+
diff --git a/test/bvar_mvariable_unittest.cpp b/test/bvar_mvariable_unittest.cpp
new file mode 100644
index 0000000..8e78331
--- /dev/null
+++ b/test/bvar_mvariable_unittest.cpp
@@ -0,0 +1,237 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Date 2021/11/17 14:57:49
+
+#include <pthread.h>                                // pthread_*
+#include <cstddef>
+#include <memory>
+#include <iostream>
+#include <set>
+#include <string>
+#include <gflags/gflags.h>
+#include <gtest/gtest.h>
+#include "butil/time.h"
+#include "butil/macros.h"
+#include "bvar/bvar.h"
+#include "bvar/multi_dimension.h"
+
+static const int num_thread = 24;
+
+static const int idc_count = 20;
+static const int method_count = 20;
+static const int status_count = 50;
+static const int labels_count = idc_count * method_count * status_count;
+
+static const std::list<std::string> labels = {"idc", "method", "status"};
+
+struct thread_perf_data {
+    bvar::MVariable* mbvar;
+    bvar::Variable*  rbvar;
+    bvar::Variable*  wbvar;
+};
+
+class MVariableTest : public testing::Test {
+protected:
+    void SetUp() {}
+    void TearDown() {
+    }
+};
+
+namespace foo {
+namespace bar {
+class Apple {};
+class BaNaNa {};
+class Car_Rot {};
+class RPCTest {};
+class HELLO {};
+}
+}
+
+TEST_F(MVariableTest, expose) {
+    std::vector<std::string> list_exposed_vars;
+    std::list<std::string> labels_value1 {"bj", "get", "200"};
+    bvar::MultiDimension<bvar::Adder<int> > my_madder1(labels);
+    ASSERT_EQ(0UL, bvar::MVariable::count_exposed());
+    my_madder1.expose("request_count_madder");
+    ASSERT_EQ(1UL, bvar::MVariable::count_exposed());
+    bvar::Adder<int>* my_adder1 = my_madder1.get_stats(labels_value1);
+    ASSERT_TRUE(my_adder1);
+    ASSERT_STREQ("request_count_madder", my_madder1.name().c_str());
+
+    ASSERT_EQ(0, my_madder1.expose("request_count_madder_another"));
+    ASSERT_STREQ("request_count_madder_another", my_madder1.name().c_str());
+
+    ASSERT_EQ(0, my_madder1.expose("request-count::madder"));
+    ASSERT_STREQ("request_count_madder", my_madder1.name().c_str());
+
+    ASSERT_EQ(0, my_madder1.expose("request.count-madder::BaNaNa"));
+    ASSERT_STREQ("request_count_madder_ba_na_na", my_madder1.name().c_str());
+
+    ASSERT_EQ(0, my_madder1.expose_as("foo::bar::Apple", "request"));
+    ASSERT_STREQ("foo_bar_apple_request", my_madder1.name().c_str());
+
+    ASSERT_EQ(0, my_madder1.expose_as("foo.bar::BaNaNa", "request"));
+    ASSERT_STREQ("foo_bar_ba_na_na_request", my_madder1.name().c_str());
+
+    ASSERT_EQ(0, my_madder1.expose_as("foo::bar.Car_Rot", "request"));
+    ASSERT_STREQ("foo_bar_car_rot_request", my_madder1.name().c_str());
+
+    ASSERT_EQ(0, my_madder1.expose_as("foo-bar-RPCTest", "request"));
+    ASSERT_STREQ("foo_bar_rpctest_request", my_madder1.name().c_str());
+
+    ASSERT_EQ(0, my_madder1.expose_as("foo-bar-HELLO", "request"));
+    ASSERT_STREQ("foo_bar_hello_request", my_madder1.name().c_str());
+
+    my_madder1.expose("request_count_madder");
+    ASSERT_STREQ("request_count_madder", my_madder1.name().c_str());
+    list_exposed_vars.push_back("request_count_madder");
+
+    ASSERT_EQ(1UL, my_madder1.count_stats());
+    ASSERT_EQ(1UL, bvar::MVariable::count_exposed());
+
+    std::list<std::string> labels2 {"user", "url", "cost"};
+    bvar::MultiDimension<bvar::Adder<int> > my_madder2("client_url", labels2);
+    ASSERT_EQ(2UL, bvar::MVariable::count_exposed());
+    list_exposed_vars.push_back("client_url");
+
+    std::list<std::string> labels3 {"product", "system", "module"};
+    bvar::MultiDimension<bvar::Adder<int> > my_madder3("request_from", labels3);
+    list_exposed_vars.push_back("request_from");
+    ASSERT_EQ(3UL, bvar::MVariable::count_exposed());
+
+    std::vector<std::string> exposed_vars;
+    bvar::MVariable::list_exposed(&exposed_vars);
+    ASSERT_EQ(3, exposed_vars.size());
+
+    my_madder3.hide();
+    ASSERT_EQ(2UL, bvar::MVariable::count_exposed());
+    list_exposed_vars.pop_back();
+    exposed_vars.clear();
+    bvar::MVariable::list_exposed(&exposed_vars);
+    ASSERT_EQ(2, exposed_vars.size());
+}
+
+TEST_F(MVariableTest, labels) {
+    std::list<std::string> labels_value1 {"bj", "get", "200"};
+    bvar::MultiDimension<bvar::Adder<int> > my_madder1("request_count_madder", labels);
+
+    ASSERT_EQ(labels.size(), my_madder1.count_labels());
+    ASSERT_STREQ("request_count_madder", my_madder1.name().c_str());
+
+    ASSERT_EQ(labels, my_madder1.labels());
+
+    std::list<std::string> labels_too_long;
+    std::list<std::string> labels_max;
+    int labels_too_long_count = 15;
+    for (int i = 0; i < labels_too_long_count; ++i) {
+        std::ostringstream os;
+        os << "label" << i;
+        labels_too_long.push_back(os.str());
+        if (i < 10) {
+            labels_max.push_back(os.str());
+        }
+    }
+    ASSERT_EQ(labels_too_long_count, labels_too_long.size());
+    bvar::MultiDimension<bvar::Adder<int> > my_madder2("request_labels_too_long", labels_too_long);
+    ASSERT_EQ(10, my_madder2.count_labels());
+    ASSERT_EQ(labels_max, my_madder2.labels());
+}
+
+TEST_F(MVariableTest, dump) {
+    std::string old_bvar_dump_interval;
+    std::string old_mbvar_dump;
+    std::string old_mbvar_dump_prefix;
+    std::string old_mbvar_dump_format;
+
+    GFLAGS_NS::GetCommandLineOption("bvar_dump_interval", &old_bvar_dump_interval);
+    GFLAGS_NS::GetCommandLineOption("mbvar_dump", &old_mbvar_dump);
+    GFLAGS_NS::GetCommandLineOption("mbvar_dump_prefix", &old_mbvar_dump_prefix);
+    GFLAGS_NS::GetCommandLineOption("mbvar_dump_format", &old_mbvar_dump_format);
+
+    GFLAGS_NS::SetCommandLineOption("bvar_dump_interval", "1");
+    GFLAGS_NS::SetCommandLineOption("mbvar_dump", "true");
+    GFLAGS_NS::SetCommandLineOption("mbvar_dump_prefix", "my_mdump_prefix");
+    GFLAGS_NS::SetCommandLineOption("mbvar_dump_format", "common");
+
+    bvar::MultiDimension<bvar::Adder<int> > my_madder("dump_adder", labels);
+    std::list<std::string> labels_value1 {"gz", "post", "200"};
+    bvar::Adder<int>* adder1 = my_madder.get_stats(labels_value1);
+    ASSERT_TRUE(adder1);
+    *adder1 << 1 << 3 << 5;
+
+    std::list<std::string> labels_value2 {"tc", "get", "200"};
+    bvar::Adder<int>* adder2 = my_madder.get_stats(labels_value2);
+    ASSERT_TRUE(adder2);
+    *adder2 << 2 << 4 << 6;
+
+    std::list<std::string> labels_value3 {"jx", "post", "500"};
+    bvar::Adder<int>* adder3 = my_madder.get_stats(labels_value3);
+    ASSERT_TRUE(adder3);
+    *adder3 << 3 << 6 << 9;
+
+    bvar::MultiDimension<bvar::Maxer<int> > my_mmaxer("dump_maxer", labels);
+    bvar::Maxer<int>* maxer1 = my_mmaxer.get_stats(labels_value1);
+    ASSERT_TRUE(maxer1);
+    *maxer1 << 3 << 1 << 5;
+
+    bvar::Maxer<int>* maxer2 = my_mmaxer.get_stats(labels_value2);
+    ASSERT_TRUE(maxer2);
+    *maxer2 << 2 << 6 << 4;
+
+    bvar::Maxer<int>* maxer3 = my_mmaxer.get_stats(labels_value3);
+    ASSERT_TRUE(maxer3);
+    *maxer3 << 9 << 6 << 3;
+
+    bvar::MultiDimension<bvar::Miner<int> > my_mminer("dump_miner", labels);
+    bvar::Miner<int>* miner1 = my_mminer.get_stats(labels_value1);
+    ASSERT_TRUE(miner1);
+    *miner1 << 3 << 1 << 5;
+
+    bvar::Miner<int>* miner2 = my_mminer.get_stats(labels_value2);
+    ASSERT_TRUE(miner2);
+    *miner2 << 2 << 6 << 4;
+
+    bvar::Miner<int>* miner3 = my_mminer.get_stats(labels_value3);
+    ASSERT_TRUE(miner3);
+    *miner3 << 9 << 6 << 3;
+
+    bvar::MultiDimension<bvar::LatencyRecorder> my_mlatencyrecorder("dump_latencyrecorder", labels);
+    bvar::LatencyRecorder* my_latencyrecorder1 = my_mlatencyrecorder.get_stats(labels_value1);
+    ASSERT_TRUE(my_latencyrecorder1);
+    *my_latencyrecorder1 << 1 << 3 << 5;
+    *my_latencyrecorder1 << 2 << 4 << 6;
+    *my_latencyrecorder1 << 3 << 6 << 9;
+    sleep(2);
+    
+    GFLAGS_NS::SetCommandLineOption("bvar_dump_interval", old_bvar_dump_interval.c_str());
+    GFLAGS_NS::SetCommandLineOption("mbvar_dump", old_mbvar_dump.c_str());
+    GFLAGS_NS::SetCommandLineOption("mbvar_dump_prefix", old_mbvar_dump_prefix.c_str());
+    GFLAGS_NS::SetCommandLineOption("mbvar_dump_format", old_mbvar_dump_format.c_str());
+}
+
+TEST_F(MVariableTest, test_describe_exposed) {
+    std::list<std::string> labels_value1 {"bj", "get", "200"};
+    std::string bvar_name("request_count_describe");
+    bvar::MultiDimension<bvar::Adder<int> > my_madder1(bvar_name, labels);
+
+    std::string describe_str = bvar::MVariable::describe_exposed(bvar_name);
+
+    std::ostringstream describe_oss;
+    ASSERT_EQ(0, bvar::MVariable::describe_exposed(bvar_name, describe_oss));
+    ASSERT_STREQ(describe_str.c_str(), describe_oss.str().c_str());
+}
diff --git a/tools/parallel_http/CMakeLists.txt b/tools/parallel_http/CMakeLists.txt
index 457d600..9f80968 100644
--- a/tools/parallel_http/CMakeLists.txt
+++ b/tools/parallel_http/CMakeLists.txt
@@ -17,3 +17,5 @@
 
 add_executable(parallel_http parallel_http.cpp)
 target_link_libraries(parallel_http brpc-static ${DYNAMIC_LIB})
+install(TARGETS parallel_http
+        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
diff --git a/tools/rpc_press/CMakeLists.txt b/tools/rpc_press/CMakeLists.txt
index e50e296..f082307 100644
--- a/tools/rpc_press/CMakeLists.txt
+++ b/tools/rpc_press/CMakeLists.txt
@@ -18,3 +18,5 @@
 file(GLOB SOURCES "${PROJECT_SOURCE_DIR}/tools/rpc_press/*.cpp")
 add_executable(rpc_press ${SOURCES})
 target_link_libraries(rpc_press brpc-static ${DYNAMIC_LIB})
+install(TARGETS rpc_press
+        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
diff --git a/tools/rpc_press/info_thread.cpp b/tools/rpc_press/info_thread.cpp
index 99c9db1..51d0811 100644
--- a/tools/rpc_press/info_thread.cpp
+++ b/tools/rpc_press/info_thread.cpp
@@ -16,6 +16,7 @@
 // under the License.
 
 #include "info_thread.h"
+#include "butil/logging.h"
 
 namespace brpc {
 
diff --git a/tools/rpc_replay/info_thread.cpp b/tools/rpc_replay/info_thread.cpp
index d20d70e..51078bf 100644
--- a/tools/rpc_replay/info_thread.cpp
+++ b/tools/rpc_replay/info_thread.cpp
@@ -16,6 +16,7 @@
 // under the License.
 
 #include "info_thread.h"
+#include "butil/logging.h"
 
 namespace brpc {
 
